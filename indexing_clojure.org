#+TITLE: Indexing (Tagging) Clojure/ClojureScript Source

Typically source code is tagged statically, without running the code
(see ctags/etags). For clojure, there is indeed a way to do this, and
also a (better) way using Clojure's interaction mode, CIDER.

* Static Tag Generation
I found a question about using etags with emacs:

https://stackoverflow.com/questions/1481842/clojure-emacs-etags

The top response provides the following one-liner:

#+begin_src bash
find . \! -name '.*' -name '*.clj' | xargs etags --regex='/[ \t\(]*def[a-z]* \([a-z-!]+\)/\1/' --regex='/[ \t\(]*ns \([a-z.]+\)/\1/'
#+end_src

Running this failed with ~etags: Invalid range end while compiling
pattern~. I had to transpose the ~!~ and the ~-~ to get it to work:

#+begin_src bash
find . \! -name '.*' -name '*.cljs' | xargs etags --regex='/[ \t\(]*def[a-z]* \([a-z!-]+\)/\1/' --regex='/[ \t\(]*ns \([a-z.]+\)/\1/'
#+end_src

There is also a way to do this with ctags:

#+begin_src emacs-lisp
  (defvar path-to-ctags "/usr/local/bin/ctags")

  ;; Recursively generate tags for all *.clj files, 
  ;; creating tags for def* and namespaces
  (defun create-clj-tags (dir-name)
    "Create tags file."
    (interactive "DDirectory: ")
    (shell-command
     (format "%s  --langdef=Clojure --langmap=Clojure:.clj --regex-Clojure='/[ \t\(]*def[a-z]* \([a-z!-]+\)/\1/'  --regex-Clojure='/[ \t\(]*ns \([a-z.]+\)/\1/' -f %s/TAGS -e -R %s" path-to-ctags dir-name (directory-file-name dir-name))))
#+end_src

This solution did not work right away for me. It did work with the
deprecated ~find-tag~, but not with its replacement,
~xref-find-definitions~, despite a test definition appearing in the
generated tags table. I suspect its failure is related to differences
in the output generated by etags and ctags.

* Browsing Source Code in CIDER
CIDER implements an ~xref~ backend:

https://github.com/clojure-emacs/cider/commit/15b6d205b6311453349144afc20d7ac4a820b0ab

Once a CIDER connection has been established *and* a source buffer
compiled, ~xref-find-definitions~ can accurately jump to symbol
definitions regardless of where they are (just as long as they have
successfully compiled).

