<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-11-23 Sat 00:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coding Challenges</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Coding Challenges</h1>
<p>
This is a place for me to record my work on various coding challenges
for later reference.
</p>

<div id="outline-container-org56dfb81" class="outline-2">
<h2 id="org56dfb81">Reverse a 32-bit Integer</h2>
<div class="outline-text-2" id="text-org56dfb81">
<p>
Link: <a href="https://leetcode.com/problems/reverse-integer/">https://leetcode.com/problems/reverse-integer/</a>
</p>

<p>
I used this one to try out Racket, rather than to practice word size
constraint as the problem instructs. Leetcode unfortunately requires
that your solution be called <kbd>reverse</kbd>, which causes the builtin
function of the same name to be shadowed. So we have to reimplement
list reversal with a new name:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define/contract (reverse-list l)
  (-&gt; list? list?)
  (reverse-list-helper l '()))

(define/contract (reverse-list-helper l aux)
  (-&gt; list? list? list?)
  (if (null? l)
      aux
      (reverse-list-helper (cdr l) (cons (car l) aux))))
</pre>
</div>
<p>
And then solve the problem:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define/contract (reverse x)
  (-&gt; exact-integer? number?)
    (let* ([s (number-&gt;string x)]
           [y (string-&gt;number
               (if (&lt; x 0)
                   (string-join (list "-" (reverse-string (substring s 1))) "")
                   (reverse-string s)))])
      (if (or (&lt; y -2147483648) (&gt;= y 2147483648)) 0 y)))

(define/contract (reverse-string s)
  (-&gt; string? string?)
  (list-&gt;string (reverse-list (string-&gt;list s))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb65d519" class="outline-2">
<h2 id="orgb65d519">Sierpinski Triangles</h2>
<div class="outline-text-2" id="text-orgb65d519">
<p>
Link:
<a href="https://www.hackerrank.com/challenges/functions-and-fractals-sierpinski-triangles/submissions/code/298875887">https://www.hackerrank.com/challenges/functions-and-fractals-sierpinski-triangles/submissions/code/298875887</a>
</p>

<p>
The tricky part of this problem is choosing a way to represent and
draw triangles that can be reused across iterations. One useful
observation is that at each iteration, the canvas can cleanly be
divided into rows of triangles. Using this observation, we need to
devise a way of drawing a row of triangles and identify how these rows
change at each "iteration" of generating the fractal.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(def n (Integer/parseInt (read-line)))

(def num-rows 32)
(def num-cols 63)

(def mark "1")
(def unmark "_")

(def marks (repeat mark))
(def unmarks (repeat unmark))

(defn draw-line [height vertices width line]
    (if (empty? vertices)
        (let [num-left (- num-cols width)
              complete (concat (take num-left unmarks) line)]
            (apply str (reverse complete)))
        (let [v (- (first vertices) height)
              num-unmark (- v width)
              num-mark (inc (* 2 height))
              more (concat (take num-mark marks)
                           (take num-unmark unmarks))]
            (recur height (rest vertices) (+ width (count more)) (concat more line)))))

(defn draw-row [height vertices]
    (clojure.string/join "\n" (for [h (range height)]
                                  (draw-line h vertices 0 '()))))

(defn draw-rows [height sets]
    (clojure.string/join "\n" (for [s sets]
                                  (draw-row height s))))

(def n0 (draw-rows 32 '((31))))

(def n1 (draw-rows 16 '((31)
                        (15 47))))

(def n2 (draw-rows 8 '((31)
                       (23 39)
                       (15 47)
                       (7 23 39 55))))

(defn fractalize [num-iter curr-iter height verts]
    (if (= curr-iter num-iter)
        (draw-rows height verts)
        (let [new-verts (apply concat (for [l verts]
                                          (list l (apply concat (for [v l]
                                                                    (list (- v (/ height 2))
                                                                    (+ v (/ height 2))))))))]
            (fractalize num-iter (inc curr-iter) (/ height 2) new-verts))))

(defn draw-fractal [n]
  (fractalize n 0 num-rows (list (list (dec num-rows)))))

(println (draw-fractal n))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0d32397" class="outline-2">
<h2 id="org0d32397">Unique Paths in Chicago</h2>
<div class="outline-text-2" id="text-org0d32397">
<p>
Link: <a href="https://leetcode.com/problems/unique-paths/">https://leetcode.com/problems/unique-paths/</a>
</p>

<p>
I posed this question in a practice interview because I wanted to know
how many different ways I could walk to the Y before I had to start
repeating routes. Later I found it on Leetcode:
<a href="https://leetcode.com/problems/unique-paths/">https://leetcode.com/problems/unique-paths/</a>
</p>

<p>
The best solution I've found frames this problem as moving along one
axis, and choosing at which of the cross streets to move along the
other axis. This is an combinations with replacement problem, also
known as multichoose. n multichoose k can also be thought of as a
stars and bars problem with <kbd>n+k-1</kbd> objects: choose <kbd>k</kbd> of the objects
to be stars (representing chosen elements), leaving <kbd>n-1</kbd> to be bars
(separating each of <kbd>n</kbd> cells which contain some number of the <kbd>k</kbd>
elements). This <a href="https://math.stackexchange.com/a/3903700">stackoverflow post</a> has more detail.
</p>

<p>
I'm tempted to call this solution constant-time, but really the number
of operations it performs grows as <kbd>m+n</kbd>:
</p>
<div class="org-src-container">
<pre class="src src-python">def comb(n,k):
    res = 1
    i = n
    while i &gt; n - k:
        res *= i
        i -= 1
    i = k
    while i &gt; 1:
        res = res // i
        i -= 1
    return res

class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        return comb(m+n-2,m-1)
</pre>
</div>
</div>
</div>

<div id="outline-container-org3d97527" class="outline-2">
<h2 id="org3d97527">Construct Binary Tree from Inorder and Preorder Traversals</h2>
<div class="outline-text-2" id="text-org3d97527">
<p>
Link:
<a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a>
</p>

<p>
At first, I tried a solution where I constructed a candidate tree
(leftward descending linked list according to preorder) and then using
the inorder traversal to graft the tree so that it satisfied the
inorder.
</p>

<p>
In thinking over that solution, I observed that when we start, we know
that the first element of the preorder must be the root; moreover, all
of the elements appearing before the root in the inorder must belong
to the left subtree, and the rest to the right.
</p>

<p>
A recursive structure was beginning to appear. Now we know how many
elements <kbd>k</kbd> are in the left subtree; the next <kbd>k</kbd> elements of the
preorder travsersal (after the first) must therefore represent a
preorder traversal of the left subtree.
</p>

<div class="org-src-container">
<pre class="src src-python"># Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def traverse(preorder,inorder):
    if preorder == []:
        return None
    val = preorder[0]
    pivot = inorder.index(val)
    inorderLeft = inorder[:pivot]
    inorderRight = inorder[pivot+1:]
    preorderLeft = [i for i in preorder if i in inorderLeft]
    preorderRight = [i for i in preorder if i in inorderRight]    
    return TreeNode(val,traverse(preorderLeft,inorderLeft),traverse(preorderRight,inorderRight))

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:
        return traverse(preorder,inorder)

</pre>
</div>

<p>
That solution passed all but one test case, and exceeded the time
limit. How can we avoid creating so many copies of the traversals?
</p>

<div class="org-src-container">
<pre class="src src-python"># Definition for a binary tree node.
class Solution:
    # [left,right)
    def traverse(self,pleft,pright,ileft,iright):
        if pleft &gt;= pright:
            return None
        val = self.preorder[pleft]
        pivot = self.inorder.index(val)
        numLeft = pivot-ileft
        leftNode = self.traverse(pleft+1,pleft+1+numLeft,ileft,pivot)
                      # traverse(preorderLeft,inorderLeft)
        rightNode = self.traverse(pleft+1+numLeft,pright,pivot+1,iright)
                       # traverse(preorderRight,inorderRight)
        return TreeNode(val,leftNode,rightNode)
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:
        self.preorder = preorder
        self.inorder = inorder
        return self.traverse(0,len(preorder),0,len(preorder))
</pre>
</div>
</div>
</div>

<div id="outline-container-org98cafee" class="outline-2">
<h2 id="org98cafee">Make Each Node of Perfect Binary Tree "Point Right"</h2>
<div class="outline-text-2" id="text-org98cafee">
<p>
Link:
<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">https://leetcode.com/problems/populating-next-right-pointers-in-each-node/</a>
</p>
<div class="org-src-container">
<pre class="src src-python">class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next

def rightests(node):
    if node:
        node.next = None
        rightests(node.right)

def inners(a,b):
    if a:
        a.next = b
        inners(a.right,b.left)

def sibs(a,b):
    if a:
        a.next = b
        sibs(a.left,a.right)
        sibs(b.left,b.right)
        inners(a.right,b.left)

class Solution:
    def connect(self, root: 'Optional[Node]') -&gt; 'Optional[Node]':
        if root:
            sibs(root.left,root.right)
        rightests(root)
        return root
</pre>
</div>
</div>
</div>

<div id="outline-container-org526c654" class="outline-2">
<h2 id="org526c654">Implement <kbd>x^n</kbd></h2>
<div class="outline-text-2" id="text-org526c654">
<p>
I remember implementing this in SICP using tail-recursion. I applied
the same principle to come up with this iterative solution:
</p>
<div class="org-src-container">
<pre class="src src-python">aclass Solution:
    def myPow(self, x: float, n: int) -&gt; float:
        if n &lt; 0:
            return 1/self.myPow(x,-n)
        res = 1
        while n:
            if n &amp; 1:
                res *= x
            x *= x
            n = n &gt;&gt; 1
        return res
</pre>
</div>
</div>
</div>

<div id="outline-container-org5e5891c" class="outline-2">
<h2 id="org5e5891c">Maximum Number of Colinear Points</h2>
<div class="outline-text-2" id="text-org5e5891c">
<p>
Link: <a href="https://leetcode.com/problems/max-points-on-a-line/">https://leetcode.com/problems/max-points-on-a-line/</a>
</p>

<p>
The brute-force solution is somewhat clear: for each line between two
points, check how many points it hits and return the max. The tricky
part ends up being how you store a line:
</p>
<div class="org-src-container">
<pre class="src src-python">class Solution:
    def maxPoints(self, points: List[List[int]]) -&gt; int:
        if len(points) &lt; 2:
            return len(points)
        d = {}
        dx = {}
        for i in range(len(points)):
            for j in range(i+1,len(points)):
                x1 = points[i][0]
                y1 = points[i][1]
                x2 = points[j][0]
                y2 = points[j][1]
                if x1 != x2:
                    m = (y2-y1)/(x2-x1)
                    b = y1 - m*x1
                    m2 = round(m,10)
                    b2 = round(b,10)
                    if (m2,b2) in d:
                        d[(m2,b2)] += 1
                    else:
                        d[(m2,b2)] = 1
                else:
                    if x1 in dx:
                        dx[x1] += 1
                    else:
                        dx[x1] = 1
        m1 = max(d.values()) if len(d.values()) &gt; 0 else 0
        m2 = max(dx.values()) if len(dx.values()) &gt; 0 else 0
        if m1 &gt; m2:
            pair = max(d,key=d.get)
            m = pair[0]
            b = pair[1]
            tot = 0
            for k in range(len(points)):
                if math.isclose(points[k][1],m*points[k][0]+b):
                    tot += 1
            return tot
        else:
            x = max(dx,key=dx.get)
            tot = 0
            for k in range(len(points)):
                if points[k][0] == x:
                    tot += 1
            return tot
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf543a7c" class="outline-2">
<h2 id="orgf543a7c">Median of Two Sorted Arrays</h2>
<div class="outline-text-2" id="text-orgf543a7c">
<p>
Link: <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">https://leetcode.com/problems/median-of-two-sorted-arrays/</a>
</p>

<p>
First of all, an O(n+m) solution is easy: merge the two arrays in
O(n+m) time and return the median. But if we want a logarithmic
solution, we have to repetitively halve the problem.
</p>

<p>
Both are sorted, so we can binary search them "together"
somehow. Perhaps we can start with a bound on the median and tighten
it.
</p>

<p>
By looking through a few examples, I identified an optimal
substructure: the overall median will sit somewhere between the first
median and the second, which means we can sort of knock of half of the
array left of the lower median, and half of the array right of the
greater median. The name of the game ended up being properly
addressing edge cases:
</p>
<div class="org-src-container">
<pre class="src src-python">def getMedianSorted(l,r,n):
    # if empty, return anything
    if r &lt;= l:
        return -42069
    i = (l+r) // 2
    m = 0
    if (r-l) % 2 == 0:
        m =  (n[i-1] + n[i]) / 2
    else:
        m = n[i]
    return m

def getMedianWithExtras(n,l,r,e):
    if (r-l) % 2 == 0:
        i = (r+l)//2 - 1
        a = sorted(n[i-len(e):i+len(e)+2]+e)
        return getMedianSorted(0,len(a),a)
    else:
        i = (r+l)//2
        a = sorted(n[i-len(e):i+len(e)+1]+e)
        return getMedianSorted(0,len(a),a)

class Solution:
    def getMedian(self,l1,r1,l2,r2):
        # if one is empty, we return the median of the other
        if l1 == r1:
            return getMedianSorted(l2,r2,self.nums2)
        if l2 == r2:
            return getMedianSorted(l1,r1,self.nums1)
        # next check the medians
        m1 = getMedianSorted(l1,r1,self.nums1)
        m2 = getMedianSorted(l2,r2,self.nums2)
        if m1 == m2:
            return m1
        if r1-l1 &lt; 6 and r2-l2 &lt; 6:
            arr = sorted(self.nums1[l1:r1]+self.nums2[l2:r2])
            return getMedianSorted(0,len(arr),arr)
        # we may get to a case where 1 array has 2 elements, which we can't reduce!
        if r1-l1 &lt; 3:
            return getMedianWithExtras(self.nums2,l2,r2,self.nums1[l1:r1])
        if r2-l2 &lt; 3:
            return getMedianWithExtras(self.nums1,l1,r1,self.nums2[l2:r2])
        numOutL = int((r1-l1-1)//2)
        numOutR = int((r2-l2-1)//2)
        numOut = min(numOutL,numOutR)
        if m1 &lt; m2:
            return self.getMedian(l1+numOut,r1,l2,r2-numOut)
        else:
            return self.getMedian(l1,r1-numOut,l2+numOut,r2)

    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:
        # it is given that m+n &gt;= 1
        self.nums1 = nums1
        self.nums2 = nums2
        return self.getMedian(0,len(nums1),0,len(nums2))
</pre>
</div>
</div>
</div>

<div id="outline-container-org17b33af" class="outline-2">
<h2 id="org17b33af">How many trailing zeroes in <kbd>n!</kbd>?</h2>
<div class="outline-text-2" id="text-org17b33af">
<p>
Link: <a href="https://leetcode.com/problems/factorial-trailing-zeroes/">https://leetcode.com/problems/factorial-trailing-zeroes/</a>
A good application for the fundamental theorem of arithmetic!
</p>
<div class="org-src-container">
<pre class="src src-python">class Solution:
    def getPrimesInFact(self,prime,fact):
        acc = 0
        i = prime
        while i &lt;= fact:
            acc += fact // i
            i *= prime
        return acc

    def trailingZeroes(self, n: int) -&gt; int:
        twos = self.getPrimesInFact(2,n)
        fives = self.getPrimesInFact(5,n)
        return min(twos,fives)
</pre>
</div>
<p>
It wasn't until after looking at the solution that I realized that
the prime factorization of <kbd>n!</kbd> is always saturated with twos! The
first call to <kbd>getPrimesInFact</kbd> is unnecessary.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p>hi</p>
</div>
</body>
</html>
