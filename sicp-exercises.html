<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-11-23 Sat 00:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SICP Exercises</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">SICP Exercises</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgb1f4978">Chapter 1</a>
<ul>
<li><a href="#org3474da8">Notes</a></li>
<li><a href="#org06f91d4">Section 1.1</a>
<ul>
<li><a href="#orgdee3083">Exercise 1.3</a></li>
<li><a href="#org2ba8ce8">Exercise 1.6</a></li>
</ul>
</li>
<li><a href="#org1510cc0">Section 1.2</a>
<ul>
<li><a href="#org36e896f">Exercise 1.9</a></li>
<li><a href="#orgfa4d7a7">Exercise 1.11</a></li>
<li><a href="#orga224d6d">Exercise 1.12</a></li>
<li><a href="#orga386c44">Exercise 1.16</a></li>
<li><a href="#orgd5f766c">Exercise 1.17</a></li>
<li><a href="#orgacaa8ee">Exercise 1.18</a></li>
<li><a href="#orgd769f4e">Exercise 1.19</a></li>
<li><a href="#orgbb9c2ef">Exercise 1.22</a></li>
<li><a href="#org57bc50c">Exercise 1.26</a></li>
<li><a href="#org6fedb41">Exercise 1.27</a></li>
</ul>
</li>
<li><a href="#orgb0fa172">Section 1.3</a>
<ul>
<li><a href="#orgdc6df6b">Exercise 1.29</a></li>
<li><a href="#org57b7b99">Exercise 1.30</a></li>
<li><a href="#org925ad90">Exercise 1.31</a></li>
<li><a href="#org3ce7e3d">Exercise 1.32</a></li>
<li><a href="#org4db2ab4">Exercise 1.33</a></li>
<li><a href="#orgdaeda9f">Exercise 1.35</a></li>
<li><a href="#org02e9fd5">Exercise 1.36</a></li>
<li><a href="#orge1055eb">Exercise 1.37</a></li>
<li><a href="#orgb896f94">Exercise 1.38</a></li>
<li><a href="#org27a8946">Exercise 1.39</a></li>
<li><a href="#org3cc8498">Exercise 1.40</a></li>
<li><a href="#orgb5b87f6">Exercise 1.41</a></li>
<li><a href="#orga784b0d">Exercise 1.42</a></li>
<li><a href="#org9527793">Exercise 1.43</a></li>
<li><a href="#orgd502e4f">Exercise 1.44</a></li>
<li><a href="#orgadb3294">Exercise 1.45</a></li>
<li><a href="#org892a3bb">Exercise 1.46</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org39a3dd2">Chapter 2</a>
<ul>
<li><a href="#orge5a7d06">Section 2.1</a>
<ul>
<li><a href="#orgb591a09">Exercise 2.1</a></li>
<li><a href="#orgea3d465">Exercise 2.2</a></li>
<li><a href="#orgd0c2c0d">Exercise 2.3</a></li>
<li><a href="#orgd8228bf">Exercise 2.4</a></li>
<li><a href="#orgc33da00">Exercise 2.5</a></li>
<li><a href="#org6ad5194">Exercise 2.6</a></li>
<li><a href="#orgeb35f48">Exercise 2.7</a></li>
<li><a href="#org5d01273">Exercise 2.8</a></li>
<li><a href="#orgae5a8c6">Exercise 2.9</a></li>
<li><a href="#orgff081b7">Exercise 2.10</a></li>
<li><a href="#org41fe53d">Exercise 2.11</a></li>
<li><a href="#org65b76a0">Exercise 2.12</a></li>
<li><a href="#orgb7796e4">Exercise 2.13</a></li>
<li><a href="#orgc9bd86a">Exercise 2.14</a></li>
</ul>
</li>
<li><a href="#org0bb4fb3">Section 2.2</a>
<ul>
<li><a href="#org40719ab">Exercise 2.17</a></li>
<li><a href="#org54751ae">Exercise 2.18</a></li>
<li><a href="#orgb491b88">Exercise 2.19</a></li>
<li><a href="#org8de135e">Exercise 2.20</a></li>
<li><a href="#org3aea5c7">Exercise 2.21</a></li>
<li><a href="#orgb4ea566">Exercise 2.22</a></li>
<li><a href="#org11a3df7">Exercise 2.23</a></li>
<li><a href="#orgd108743">Exercise 2.25</a></li>
<li><a href="#orgda6a942">Exercise 2.27</a></li>
<li><a href="#org002f5c2">Exercise 2.28</a></li>
<li><a href="#org18aab3e">Exercise 2.29</a></li>
<li><a href="#orgf7488ae">Exercise 2.30</a></li>
<li><a href="#org2e48277">Exercise 2.31</a></li>
<li><a href="#org5aee4b3">Exercise 2.32</a></li>
<li><a href="#org3765fb4">Exercise 2.33</a></li>
<li><a href="#org0cf1e26">Exercise 2.34</a></li>
<li><a href="#org96a44bc">Exercise 2.35</a></li>
<li><a href="#org8721684">Exercise 2.36</a></li>
<li><a href="#org74d857a">Exercise 2.37</a></li>
<li><a href="#org2d6aa1b">Exercise 2.38</a></li>
<li><a href="#org7652627">Exercise 2.39</a></li>
<li><a href="#org6921f73">Exercise 2.40</a></li>
<li><a href="#orgafe7f97">Exercise 2.41</a></li>
<li><a href="#org0ff20ad">Exercise 2.42</a></li>
<li><a href="#orgbd0da25">Exercise 2.43</a></li>
<li><a href="#orgf614b83">Exercise 2.44</a></li>
<li><a href="#org4d8e5ce">Exercise 2.45</a></li>
<li><a href="#org114f751">Exercise 2.46</a></li>
<li><a href="#orga27c5e3">Exercise 2.47</a></li>
<li><a href="#org55a0b11">Exercise 2.48</a></li>
<li><a href="#orge1371db">Exercise 2.49</a></li>
<li><a href="#org8997f51">Exercise 2.51</a></li>
</ul>
</li>
<li><a href="#org6d27cc0">Section 2.3</a>
<ul>
<li><a href="#orgd8eb0eb">Exercise 2.53</a></li>
<li><a href="#org0ff2104">Exercise 2.54</a></li>
<li><a href="#org18e7ecf">Exercise 2.55</a></li>
<li><a href="#orgbd2a918">Exercise 2.56</a></li>
<li><a href="#orga2fa15d">Exercise 2.57</a></li>
<li><a href="#org7c646da">Exercise 2.58</a></li>
<li><a href="#orgb8057a0">Exercise 2.59</a></li>
<li><a href="#orgd2afece">Exercise 2.60</a></li>
<li><a href="#org968af46">Exercise 2.61</a></li>
<li><a href="#org0ee4bc4">Exercise 2.62</a></li>
<li><a href="#orga498e6b">Exercise 2.63</a></li>
<li><a href="#orgab31bf6">Exercise 2.64</a></li>
<li><a href="#org2c777e2">Exercise 2.65</a></li>
<li><a href="#org0ae9a1e">Exercise 2.67</a></li>
<li><a href="#orgb0de37b">Exercise 2.68</a></li>
<li><a href="#org60662c4">Exercise 2.69</a></li>
<li><a href="#org01b9cb8">Exercise 2.70</a></li>
<li><a href="#org374a906">Exercise 2.71</a></li>
<li><a href="#org06d06ef">Exercise 2.72</a></li>
</ul>
</li>
<li><a href="#org7c3e17c">Section 2.4</a>
<ul>
<li><a href="#org6da81a1">Exercise 2.73</a></li>
</ul>
</li>
<li><a href="#orgc1076c0">Section 2.5</a>
<ul>
<li><a href="#org28d0c90">Exercise 2.77</a></li>
<li><a href="#orgf09d96e">Exercise 2.78</a></li>
<li><a href="#org8a31936">Exercise 2.79</a></li>
<li><a href="#org148957c">Exercise 2.80</a></li>
<li><a href="#orgfc16353">Exercise 2.81</a></li>
<li><a href="#org10c2472">Exercise 2.82</a></li>
<li><a href="#org4a89343">Exercise 2.83</a></li>
<li><a href="#org2762a4b">Exercise 2.84</a></li>
<li><a href="#org04aff87">Exercise 2.85</a></li>
<li><a href="#orga0b4f5e">Exercise 2.86</a></li>
<li><a href="#orgf1a8230">Exercise 2.87</a></li>
<li><a href="#org722c093">Exercise 2.88</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb1f4978" class="outline-2">
<h2 id="orgb1f4978">Chapter 1</h2>
<div class="outline-text-2" id="text-orgb1f4978">
</div>
<div id="outline-container-org3474da8" class="outline-3">
<h3 id="org3474da8">Notes</h3>
<div class="outline-text-3" id="text-org3474da8">
<p>
A recursive procedure is simply one that calls itself by name. It is
not necessarily a recursive process.
</p>
<blockquote>
<p>
Programs must be written for people to read, and only incidentally
for computers to execute
</p>
</blockquote>
<blockquote>
<p>
The set of expressions for which a binding defines a name is called
the scope of that name
</p>
</blockquote>
<p>
<kbd>let</kbd> is syntactic sugar for <kbd>lambda</kbd> application
</p>
<blockquote>
<p>
The general technique of isolating the parts of a program that deal
with how data objects are represented from the parts of a program
that deal with how data objects are used is a powerful design
methodology called "data abstraction".
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org06f91d4" class="outline-3">
<h3 id="org06f91d4">Section 1.1</h3>
<div class="outline-text-3" id="text-org06f91d4">
</div>
<div id="outline-container-orgdee3083" class="outline-4">
<h4 id="orgdee3083">Exercise 1.3</h4>
<div class="outline-text-4" id="text-orgdee3083">
<div class="org-src-container">
<pre class="src src-scheme">(define (square x)
  (* x x))
(define (sum-of-squares-of-largest a b c)
  (- (+ (square a) (square b) (square c))
     (cond ((and (&lt; a b) (&lt; a c)) a)
           ((&lt; b c) b)
           (else c))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org2ba8ce8" class="outline-4">
<h4 id="org2ba8ce8">Exercise 1.6</h4>
<div class="outline-text-4" id="text-org2ba8ce8">
<p>
Enters a recursive loop not because <kbd>cond</kbd> is used instead of <kbd>if</kbd> but
because a function call is used instead of <kbd>if</kbd> or <kbd>cond</kbd>. If <kbd>new-if</kbd>
were implemented with <kbd>if</kbd> instead of <kbd>cond</kbd>, the code would also
enter an infinite loop.
</p>
</div>
</div>
</div>
<div id="outline-container-org1510cc0" class="outline-3">
<h3 id="org1510cc0">Section 1.2</h3>
<div class="outline-text-3" id="text-org1510cc0">
</div>
<div id="outline-container-org36e896f" class="outline-4">
<h4 id="org36e896f">Exercise 1.9</h4>
<div class="outline-text-4" id="text-org36e896f">
<p>
Recursive:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(+ 4 5)
(inc (+ (dec 4) 5))
(inc (+ 3 5))
(inc (inc (+ (dec 3) 5)))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ (dec 2) 5))))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ (dec 1) 5)))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
</pre>
</div>
<p>
Iterative:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9
</pre>
</div>
<div class="org-src-container">
<pre class="src src-scheme">(define (my-count-change amt values)
  (cond ((null? values) 0)
        ((&lt; amt 0) 0)
        ((= amt 0) 1)
        (else (+ (my-count-change (- amt (car values)) values)
                 (my-count-change amt (cdr values))))))

(define (count-change amt)
  (define (cc amount kinds-of-coins)
    (cond ((= amount 0) 1)
          ((or (&lt; amount 0) (= kinds-of-coins 0)) 0)
          (else (+ (cc amount
                       (- kinds-of-coins 1))
                   (cc (- amount
                          (first-denomination kinds-of-coins))
                       kinds-of-coins)))))
  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))
  (cc amt 5))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfa4d7a7" class="outline-4">
<h4 id="orgfa4d7a7">Exercise 1.11</h4>
<div class="outline-text-4" id="text-orgfa4d7a7">
<div class="org-src-container">
<pre class="src src-scheme">(define (f n)
  (if (&lt; n 3)
      n
      (+ (* 1 (f (- n 1)))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))
(define (f-iter n)
  (define (iterate a b c count)
    (if (= count 0)
        a
        (iterate b
                c
                (+ c
                   (* b 2)
                   (* a 3))
                (- count 1))))
  (iterate 0 1 2 n))
</pre>
</div>
</div>
</div>
<div id="outline-container-orga224d6d" class="outline-4">
<h4 id="orga224d6d">Exercise 1.12</h4>
<div class="outline-text-4" id="text-orga224d6d">
<div class="org-src-container">
<pre class="src src-scheme">(define (pascal n m)
  (if (or (= m 0)
          (= m n))
      1
      (+ (pascal (- n 1) (- m 1))
         (pascal (- n 1) m))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orga386c44" class="outline-4">
<h4 id="orga386c44">Exercise 1.16</h4>
<div class="outline-text-4" id="text-orga386c44">
<p>
If \(n\) is even:
\[b \to b^{2}\]
\[n \to \frac{n}{2} - 1\]
\[c \to cb^{2}\]
If \(n\) is odd:
\[b \to b\]
\[n \to n - 1\]
\[c \to cb\]
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (fast-expt base exp)
  (define (fast-iter b n c)
    (cond ((= n 0) c)
          ((even? n) (fast-iter (* b b) (- (/ n 2) 1) (* c (* b b))))
          (else (fast-iter b (- n 1) (* c b)))))
  (fast-iter base exp 1))
(define (even? n)
  (= (remainder n 2) 0))

;; And so here are all of the combinations of space-/time-complexity
;; we've seen so far:

(define (my-expt b n)
  (if (= n 0)
      1
      (* b (my-expt b (- n 1)))))

(define (my-expt-iter base pow)
  (define (iterate n c)
    (cond ((= n 0) c)
          (else (iterate (- n 1) (* base c)))))
  (iterate pow 1))

(define (my-expt-log base pow)
  (cond ((= pow 0) 1)
        ((even? pow) (square (my-expt-log base (/ pow 2))))
        (else (* base (my-expt-log base (- pow 1))))))

(define (my-expt-iter-log base pow)
  (define (iterate b p c)
    (cond ((= p 0) c)
          ((even? p) (iterate (* b b) (/ p 2) c))
          (else (iterate b (- p 1) (* b c)))))
  (iterate base pow 1))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd5f766c" class="outline-4">
<h4 id="orgd5f766c">Exercise 1.17</h4>
<div class="outline-text-4" id="text-orgd5f766c">
<div class="org-src-container">
<pre class="src src-scheme">(define (halve b)
  (/ b 2))
(define (double b)
  (+ b b))
(define (mult a b)
  (cond ((= b 0) 0)
        ((even? b) (double (mult a (halve b))))
        (else (+ a (mult a (- b 1))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgacaa8ee" class="outline-4">
<h4 id="orgacaa8ee">Exercise 1.18</h4>
<div class="outline-text-4" id="text-orgacaa8ee">
<div class="org-src-container">
<pre class="src src-scheme">(define (fast-mult x y)
  (define (fast-mult-iter a b c)
    (cond ((= b 0) c)
          ((even? b) (fast-mult-iter (double a) (- (halve b) 1) (+ c (double a))))
          (else (fast-mult-iter a (- b 1) (+ c a)))))
  (fast-mult-iter x y 0))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd769f4e" class="outline-4">
<h4 id="orgd769f4e">Exercise 1.19</h4>
<div class="outline-text-4" id="text-orgd769f4e">
<p>
If we use as a representation for the iterative fibonacci process a
transformation \(T_{p,q}\) defined as:
\[a \leftarrow bq + aq + ap\]
\[b \leftarrow bp + aq\]
Then $t<sub>p',q'</sub> = \(T_{p,q} \circ T_{p,q}\) is:
\[a \leftarrow (bp + aq)q + (bq + aq + ap)q + (bq + aq + ap)p\]
\[b \leftarrow (bp + aq)p + (bq + aq + ap)q\]
We'll rewrite this to determine p' and q':
\[a \leftarrow b(2pq+q^2) + a(2q^2 + 2qp + p^2)\]
\[b \leftarrow b(p^2+q^2) + a(2qp+q^2)\]
Therefore \(p' = p^2+q^2\) and \(q' = 2pq+q^2\).
</p>

<p>
The exercise doesn't elucidate the origin of this cleverly defined
transformation. Apparently it's called the "Fibonacci Q-Matrix" and
originated in the 1950s (see <a href="https://stackoverflow.com/questions/1896974/sicp-exercise-1-19">stackoverflow</a> for more).
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (fib n)
  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a
                     b
                     (+ (square p) (square q))
                     (+ (* 2 p q) (square q))
                     (/ count 2)))
          (else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1)))))
  (fib-iter 1 0 0 1 n))

(define (my-expmod base exp mod)
  "Generates an iterative process that runs in a logarithmic number of steps"
  (define (iterate b e i)
    (cond ((= e 0) i)
          ((even? e) (iterate (remainder (* b b) mod) (/ e 2) i))
          (else (iterate b (- e 1) (remainder (* b i) mod)))))
  (iterate base exp 1))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbb9c2ef" class="outline-4">
<h4 id="orgbb9c2ef">Exercise 1.22</h4>
<div class="outline-text-4" id="text-orgbb9c2ef">
<div class="org-src-container">
<pre class="src src-scheme">(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
(define (search-for-primes a b)
  (cond ((&lt; a b) (timed-prime-test a)
                 (search-for-primes (+ a 1) b))))
(define (prime? n)
  (define (iterate i)
    (cond ((= (remainder n i) 0) #f)
          ((&gt; (* i i) n) #t)
          (else (iterate (+ i 1)))))
  (iterate 2))
</pre>
</div>
</div>
</div>
<div id="outline-container-org57bc50c" class="outline-4">
<h4 id="org57bc50c">Exercise 1.26</h4>
<div class="outline-text-4" id="text-org57bc50c">
<p>
From a high level, calling <kbd>expmod</kbd> with <kbd>(/ exp 2)</kbd> halves the
problem. It is this halving, at each iteration of the process, that
allows it to run in a number of steps that is logarithmically
related to the size of the input. When Louis calls <kbd>expmod</kbd> twice,
each with a halved problem (the same half) he is doing twice of
half of the original amount of work. Therefore he is doing the
original amount of work, which in the case of computing an exponent
would be \(n\) multiplications where \(n\) is the power being raised to.
</p>
</div>
</div>
<div id="outline-container-org6fedb41" class="outline-4">
<h4 id="org6fedb41">Exercise 1.27</h4>
<div class="outline-text-4" id="text-org6fedb41">
<div class="org-src-container">
<pre class="src src-scheme">(define (fermat-condition? a n)
  (= (my-expmod a n n) (remainder a n)))
(define (fermat-test? n)
  (define (satisfies? a)
    (cond ((&gt;= a n) #t)
          ((fermat-condition? a n) (satisfies? (+ a 1)))
          (else #f)))
  (satisfies? 2))
(define (carmichael? n)
  (and (not (prime? n)) (fermat-test? n)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb0fa172" class="outline-3">
<h3 id="orgb0fa172">Section 1.3</h3>
<div class="outline-text-3" id="text-orgb0fa172">
</div>
<div id="outline-container-orgdc6df6b" class="outline-4">
<h4 id="orgdc6df6b">Exercise 1.29</h4>
<div class="outline-text-4" id="text-orgdc6df6b">
<div class="org-src-container">
<pre class="src src-scheme">(define (simp f a b n)
  (define h (/ (- b a) n))
  (define (step x) (+ x h h))
  (define (cf c x) (* c (f x)))
  (define (2f x) (cf 2 x))
  (define (4f x) (cf 4 x))
  (* (/ h 3.0)
     (+ (f a)
        (sum 4f (+ a h) step b)
        (sum 2f (+ a h h) step b)
        (f b))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org57b7b99" class="outline-4">
<h4 id="org57b7b99">Exercise 1.30</h4>
<div class="outline-text-4" id="text-org57b7b99">
<div class="org-src-container">
<pre class="src src-scheme">(define (sum term a next b)
  (define (iter a result)
     (if (&gt; a b)
         result
         (iter (next a) (+ result (term a)))))
  (iter a 0))
</pre>
</div>
</div>
</div>
<div id="outline-container-org925ad90" class="outline-4">
<h4 id="org925ad90">Exercise 1.31</h4>
<div class="outline-text-4" id="text-org925ad90">
<div class="org-src-container">
<pre class="src src-scheme">(define (product-iter term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (* result (term a)))))
  (iter a 1))
(define (product term a next b)
  (if (&gt; a b)
      1
      (* (term a)
         (product term (next a) next b))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org3ce7e3d" class="outline-4">
<h4 id="org3ce7e3d">Exercise 1.32</h4>
<div class="outline-text-4" id="text-org3ce7e3d">
<div class="org-src-container">
<pre class="src src-scheme">(define (accumulate combiner null-val term a next b)
  (if (&gt; a b)
      null-val
      (combiner (term a)
                (accumulate combiner null-val term (next a) next b))))
(define (accumulate-iter combiner null-val term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (combiner result (term a)))))
  (iter a null-val))
</pre>
</div>
</div>
</div>
<div id="outline-container-org4db2ab4" class="outline-4">
<h4 id="org4db2ab4">Exercise 1.33</h4>
<div class="outline-text-4" id="text-org4db2ab4">
<div class="org-src-container">
<pre class="src src-scheme">(define (filtered-accumulate filter combiner null-val term a next b)
  (define (iter a result)
    (cond ((&gt; a b) result)
          ((filter a) (iter (next a) (combiner result (term a))))
          (else (iter (next a) (combiner result null-val)))))
  (iter a null-val))
(define (sum-square-primes a b)
  (filtered-accumulate prime? + 0 square a inc b))
(define (product-coprimes n)
  (define (filt a)
    (= (gcd a n) 1))
  (filtered-accumulate filt * 1 (lambda (x) x) 2 inc n))
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

(define (factorial b)
  (product (lambda (x) x) 2 (lambda (x) (+ x 1)) b))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-scheme">(define (4square x)
  (* 4 (square x)))
(define (4square1 x)
  (- (4square x) 1))
(define (inc x)
  (+ x 1))
(define (pi-approx n)
  (* 2.0 (/ (product-iter 4square 1 inc n)
            (product-iter 4square1 1 inc n))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdaeda9f" class="outline-4">
<h4 id="orgdaeda9f">Exercise 1.35</h4>
<div class="outline-text-4" id="text-orgdaeda9f">
<p>
\[x^{2} \mapsto x + 1\]
\[x^{2} - x - 1 = 0\]
\[x = \frac{-(-1) \pm \sqrt{(-1)^{2} - 4(-1)}}{2}\]
\[x = \frac{1 \pm \sqrt{5}}{2}\]
</p>
</div>
</div>
<div id="outline-container-org02e9fd5" class="outline-4">
<h4 id="org02e9fd5">Exercise 1.36</h4>
<div class="outline-text-4" id="text-org02e9fd5">
<div class="org-src-container">
<pre class="src src-scheme">(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (&lt; (abs (- v1 v2)) tolerance))
  (define (try guess)
    (newline)
    (display guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
</pre>
</div>
</div>
</div>
<div id="outline-container-orge1055eb" class="outline-4">
<h4 id="orge1055eb">Exercise 1.37</h4>
<div class="outline-text-4" id="text-orge1055eb">
<div class="org-src-container">
<pre class="src src-scheme">(define (cont-frac n d k)
  (define (recurse i)
    (if (= i k)
        0
        (/ (n i)
           (+ (d i) (recurse (+ i 1))))))
  (recurse 1))
(define (cont-frac n d k)
  (define (iter i result)
    (if (= i 0)
        result
        (iter (- i 1) (/ (n i)
                         (+ (d i) result)))))
  (iter k 0))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb896f94" class="outline-4">
<h4 id="orgb896f94">Exercise 1.38</h4>
<div class="outline-text-4" id="text-orgb896f94">
<div class="org-src-container">
<pre class="src src-scheme">(define (e-approx k)
  (define (d k)
    (if (= (remainder k 3) 2)
        (+ 2.0 (* 2 (quotient k 3)))
        1.0))
  (+ 2 (cont-frac (lambda (x) 1.0) d k)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org27a8946" class="outline-4">
<h4 id="org27a8946">Exercise 1.39</h4>
<div class="outline-text-4" id="text-org27a8946">
<div class="org-src-container">
<pre class="src src-scheme">(define (tan-cf x k)
  (cont-frac (lambda (i) (if (= i 1)
                             x
                             (* -1.0 (square x))))
             (lambda (i) (- (* 2 i) 1.0))
             k))

</pre>
</div>
</div>
</div>
<div id="outline-container-org3cc8498" class="outline-4">
<h4 id="org3cc8498">Exercise 1.40</h4>
<div class="outline-text-4" id="text-org3cc8498">
<div class="org-src-container">
<pre class="src src-scheme">(define (cubic a b c)
  (lambda (x) (+ (cube x) (* a (square x)) (* b x) c)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb5b87f6" class="outline-4">
<h4 id="orgb5b87f6">Exercise 1.41</h4>
<div class="outline-text-4" id="text-orgb5b87f6">
<div class="org-src-container">
<pre class="src src-scheme">(define (double f)
  (lambda (x) (f (f x))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orga784b0d" class="outline-4">
<h4 id="orga784b0d">Exercise 1.42</h4>
<div class="outline-text-4" id="text-orga784b0d">
<div class="org-src-container">
<pre class="src src-scheme">(define (compose f g)
  (lambda (x) (f (g x))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org9527793" class="outline-4">
<h4 id="org9527793">Exercise 1.43</h4>
<div class="outline-text-4" id="text-org9527793">
<div class="org-src-container">
<pre class="src src-scheme">(define (repeated f n)
  (if (= n 1)
      f
      (compose f (repeated f (- n 1)))))
(define (repeated-iter f n)
  (define (iter i g)
    (if (= i n)
        g
        (iter (+ i 1) (compose f g))))
  (iter 1 f))
(define (repeated-log f n)
  (cond ((= n 1) f)
        ((even? n) (repeated-log (compose f f) (/ n 2)))
        (else (compose f (repeated-log f (- n 1))))))

</pre>
</div>
</div>
</div>
<div id="outline-container-orgd502e4f" class="outline-4">
<h4 id="orgd502e4f">Exercise 1.44</h4>
<div class="outline-text-4" id="text-orgd502e4f">
<div class="org-src-container">
<pre class="src src-scheme">(define (sum-list l)
  (if (null? l)
      0
      (+ (car l) (sum-list (cdr l)))))
(define (average-list l)
  (/ (sum-list l) (length l)))
(define (smooth f)
  (lambda (x) (average-list (list (f (- x dx))
                                  (f x)
                                  (f (+ x dx))))))
(define (n-fold-smoothed f n)
  ((repeated smooth n) f))

</pre>
</div>
</div>
</div>
<div id="outline-container-orgadb3294" class="outline-4">
<h4 id="orgadb3294">Exercise 1.45</h4>
<div class="outline-text-4" id="text-orgadb3294">
<p>
In the REPL I see the following:
</p>
<ul class="org-ul">
<li>One average-damp works until fourth roots</li>
<li>Two average-damp's work until eighth roots</li>
<li>Three average-damp's work until sixteenth roots</li>
</ul>
<p>
I see a pattern&#x2026;
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (average-damp f)
  (lambda (x) (average (list x (f x)))))
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
(define (lb x)
  (/ (log x) (log 2)))
(define (nth-root k n)
  (fixed-point
   ((repeated average-damp (floor (lb n))) (lambda (x) (/ k (my-expt x (- n 1)))))
   1.0))
(define (difference a b)
  (abs (- a b)))
(define (test-nth-root base exp)
  (&lt; (difference base
                 (nth-root (my-expt base exp)
                           exp))
     0.01))
</pre>
</div>
</div>
</div>
<div id="outline-container-org892a3bb" class="outline-4">
<h4 id="org892a3bb">Exercise 1.46</h4>
<div class="outline-text-4" id="text-org892a3bb">
<div class="org-src-container">
<pre class="src src-scheme">(define (iterative-improve good-enough? improve-guess)
  (lambda (guess)
    (define (iterate g)
      (if (good-enough? g)
          g
          (iterate (improve-guess g))))
    (iterate guess)))
(define (iterative-improve-sqrt x)
  ((iterative-improve (lambda (g) (&lt; (difference (square g) x) 0.001))
                      (lambda (g) (average (list g (/ x g))))) 1.0))
(define (iterative-improve-fixed-point func first-guess)
  ((iterative-improve (lambda (g) (&lt; (difference g (func g)) 0.00001))
                      func) first-guess))
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org39a3dd2" class="outline-2">
<h2 id="org39a3dd2">Chapter 2</h2>
<div class="outline-text-2" id="text-org39a3dd2">
</div>
<div id="outline-container-orge5a7d06" class="outline-3">
<h3 id="orge5a7d06">Section 2.1</h3>
<div class="outline-text-3" id="text-orge5a7d06">
</div>
<div id="outline-container-orgb591a09" class="outline-4">
<h4 id="orgb591a09">Exercise 2.1</h4>
<div class="outline-text-4" id="text-orgb591a09">
<div class="org-src-container">
<pre class="src src-scheme">(define (same-sign? a b)
  (&gt; (* a b) 0))
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (* (cond ((same-sign? n d) 1)
                   (else -1))
             (abs (/ n g)))
          (abs (/ d g)))))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

</pre>
</div>
</div>
</div>
<div id="outline-container-orgea3d465" class="outline-4">
<h4 id="orgea3d465">Exercise 2.2</h4>
<div class="outline-text-4" id="text-orgea3d465">
<div class="org-src-container">
<pre class="src src-scheme">(define (make-point x y)
  (cons x y))
(define (x-point p) (car p))
(define (y-point p) (cdr p))
(define (point-less p1 p2)
  (or (&lt; (x-point p1) (x-point p2))
      (and (= (x-point p1) (x-point p2))
           (&lt; (y-point p1) (y-point p2)))))
(define (point-equal p1 p2)
  (and (= (x-point p1) (x-point p2))
       (= (y-point p1) (y-point p2))))
(define (point-equal p1 p2)
  (and (not (point-less p1 p2))
       (not (point-less p2 p1))))
(define (make-segment start end)
  (cond ((point-less start end) (cons start end))
        (else (cons end start))))
(define (start-segment seg) (car seg))
(define (end-segment seg) (cdr seg))
(define (average a b)
  (/ (+ a b) 2))
(define (midpoint-segment seg)
  (make-point (average (x-point (start-segment seg))
                       (x-point (end-segment seg)))
              (average (y-point (start-segment seg))
                       (y-point (end-segment seg)))))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

</pre>
</div>
</div>
</div>
<div id="outline-container-orgd0c2c0d" class="outline-4">
<h4 id="orgd0c2c0d">Exercise 2.3</h4>
<div class="outline-text-4" id="text-orgd0c2c0d">
<div class="org-src-container">
<pre class="src src-scheme">(define (make-rectangle corner1 corner2)
  (cond ((or (= (x-point corner1) (x-point corner2))
             (= (y-point corner1) (y-point corner2)))
         (error "Points define a segment"))
        ((point-less corner1 corner2) (cons corner1 corner2))
        (else (cons corner2 corner1))))
(define (height rect)
  (difference (y-point (car rect)) (y-point (cdr rect))))
(define (width rect)
  (difference (x-point (car rect)) (x-point (cdr rect))))
</pre>
</div>
<p>
I won't get much more out of this by continuing&#x2026;
</p>
</div>
</div>
<div id="outline-container-orgd8228bf" class="outline-4">
<h4 id="orgd8228bf">Exercise 2.4</h4>
<div class="outline-text-4" id="text-orgd8228bf">
<div class="org-src-container">
<pre class="src src-scheme">(define (my-cons x y)
  (lambda (m) (m x y)))
(define (my-car z)
  (z (lambda (p q) p)))
(define (my-cdr z)
  (z (lambda (p q) q)))
</pre>
</div>
<p>
Expansion:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(my-cdr (my-cons 1 2))
((my-cons 1 2) (lambda (p q) q))
((lambda (m) (m 1 2)) (lambda (p q) q))
((lambda (p q) q) 1 2)
2
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc33da00" class="outline-4">
<h4 id="orgc33da00">Exercise 2.5</h4>
<div class="outline-text-4" id="text-orgc33da00">
<div class="org-src-container">
<pre class="src src-scheme">(define (log-base base value)
  (/ (log value) (log base)))
(define (factor-out factor value)
  (if (= (remainder value factor) 0)
      (factor-out factor (/ value factor))
      value))
(define (my-cons x y)
  (* (my-expt 2 x) (my-expt 3 y)))
(define (my-car p)
  (log-base 2 (factor-out 3 p)))
(define (my-cdr p)
  (log-base 3 (factor-out 2 p)))

</pre>
</div>
</div>
</div>
<div id="outline-container-org6ad5194" class="outline-4">
<h4 id="org6ad5194">Exercise 2.6</h4>
<div class="outline-text-4" id="text-org6ad5194">
<div class="org-src-container">
<pre class="src src-scheme">(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
</pre>
</div>
<p>
Expansion:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(add-1 zero)
(lambda (f) (lambda (x) (f ((zero f) x))))
(lambda (f) (lambda (x) (f (((lambda (q) (lambda (z) z)) f) x))))
(lambda (f) (lambda (x) (f ((lambda (z) z) x))))
(lambda (f) (lambda (x) (f x)))
(lambda (f) (lambda (x) (f x)))
(add-1 (lambda (f) (lambda (x) (f x))))
(lambda (f) (lambda (x) (f (((lambda (g) (lambda (x) (g x))) f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (f (f x))))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-scheme">(define (plus a b)
  (lambda (f) (compose (a f) (b f))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgeb35f48" class="outline-4">
<h4 id="orgeb35f48">Exercise 2.7</h4>
<div class="outline-text-4" id="text-orgeb35f48">
<div class="org-src-container">
<pre class="src src-scheme">(define (make-interval a b) (cons a b))
(define (lower-bound int)
  (min (car int) (cdr int)))
(define (upper-bound int)
  (max (car int) (cdr int)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org5d01273" class="outline-4">
<h4 id="org5d01273">Exercise 2.8</h4>
<div class="outline-text-4" id="text-org5d01273">
<div class="org-src-container">
<pre class="src src-scheme">(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))

</pre>
</div>
</div>
</div>
<div id="outline-container-orgae5a8c6" class="outline-4">
<h4 id="orgae5a8c6">Exercise 2.9</h4>
<div class="outline-text-4" id="text-orgae5a8c6">
<p>
Let \(x = (a,b)\) and \(y = (c,d)\) be intervals. Then \(width(x) =
\frac{b-a}{2}\) and \(width(y) = \frac{d-c}{2}\). Well: \[width(x+y) =
width((a+c,b+d))\] \[= \frac{b+d-a-c}{2}\] \[= \frac{b-a}{2} +
\frac{d-c}{2}\] \[= width(x)+width(y)\] And: \[width(x-y) =
width((a-d,b-c))\] \[= \frac{b-c-a+d}{2}\] \[= width(x) + width(y)\]
Now let \(x_{1} = (1,2)\), \(x_{2} = (3,4)\), and \(x_{3} = (5,6)\). Then
\[width(x_{1}) = width(x_{2}) = width(x_{3}) = \frac{1}{2}\] But
\(width(x_{1}*x_{2}) = width((3,8)) = \frac{5}{2}\) and
\(width(x_{2}*x_{3}) = width(15 24) = \frac{9}{2}\). If product width
were a function only of factor widths then \(width(x_{1}*x_{2})\) would
equal \(width(x_{2}*x_{3})\) (because \(width(x_{1}) = width(x_{2}) =
width(x_{3})\)) but this is not the case. Similarly,
\[width(\frac{x_{1}}{x_{2}}) = width((\frac{1}{4},\frac{2}{3})) =
\frac{5}{24}\] \[\neq width(\frac{x_{2}}{x_{3}}) =
width((\frac{1}{3},\frac{4}{5})) = \frac{7}{30}\]
</p>
</div>
</div>
<div id="outline-container-orgff081b7" class="outline-4">
<h4 id="orgff081b7">Exercise 2.10</h4>
<div class="outline-text-4" id="text-orgff081b7">
<div class="org-src-container">
<pre class="src src-scheme">(define (width-interval x)
  (/ (- (upper-bound x) (lower-bound x)) 2))
(define (mul-interval x y)
       (let ((p1 (* (lower-bound x) (lower-bound y)))
             (p2 (* (lower-bound x) (upper-bound y)))
             (p3 (* (upper-bound x) (lower-bound y)))
             (p4 (* (upper-bound x) (upper-bound y))))
         (make-interval (min p1 p2 p3 p4)
                        (max p1 p2 p3 p4))))
(define (div-interval x y)
  (if (= (width-interval y) 0)
      (error "Division by zero-width interval")
      (mul-interval x
      (make-interval (/ 1.0 (upper-bound y))
      (/ 1.0 (lower-bound y))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org41fe53d" class="outline-4">
<h4 id="org41fe53d">Exercise 2.11</h4>
<div class="outline-text-4" id="text-org41fe53d">
<p>
If we're multiplying intervals \(i=(a,b)\) and \(j=(x,y)\) then we must have \(a \leq
b\) and \(x \leq y\) and so we have the following cases:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(a \leq b < 0\)</th>
<th scope="col" class="org-left">\(a < 0 \leq b\)</th>
<th scope="col" class="org-left">\(0 \leq a \leq b\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(x \leq y < 0\)</td>
<td class="org-left">\((by,ax)\)</td>
<td class="org-left">\((bx,ax)\)</td>
<td class="org-left">\((bx,ay)\)</td>
</tr>

<tr>
<td class="org-left">\(x < 0 \leq y\)</td>
<td class="org-left">\((ay,ax)\)</td>
<td class="org-left">\((min(ay,bx),min(ax,by))\)</td>
<td class="org-left">\((bx,by)\)</td>
</tr>

<tr>
<td class="org-left">\(0 \leq x \leq y\)</td>
<td class="org-left">\((ay,bx)\)</td>
<td class="org-left">\((ay,by)\)</td>
<td class="org-left">\((ax,by)\)</td>
</tr>
</tbody>
</table>
<p>
For simplicity's sake, we notice that multiplication is commutative
and simplify our table:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(a \leq b < 0\)</th>
<th scope="col" class="org-left">\(a < 0 \leq b\)</th>
<th scope="col" class="org-left">\(0 \leq a \leq b\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(x \leq y < 0\)</td>
<td class="org-left">\((by,ax)\)</td>
<td class="org-left">\((bx,ax)\)</td>
<td class="org-left">\((bx,ay)\)</td>
</tr>

<tr>
<td class="org-left">\(x < 0 \leq y\)</td>
<td class="org-left">\(j*i\)</td>
<td class="org-left">\((min(ay,bx),min(ax,by))\)</td>
<td class="org-left">\((bx,by)\)</td>
</tr>

<tr>
<td class="org-left">\(0 \leq x \leq y\)</td>
<td class="org-left">\(j*i\)</td>
<td class="org-left">\(j*i\)</td>
<td class="org-left">\((ax,by)\)</td>
</tr>
</tbody>
</table>
<div class="org-src-container">
<pre class="src src-scheme">(define (mul-interval i j)
  (let ((a (lower-bound i))
        (b (upper-bound i))
        (x (lower-bound j))
        (y (upper-bound j)))
    (cond ((&lt; b 0) (if (&lt; y 0)
                       (make-interval (* b y) (* a x))
                       (mul-interval j i)))
          ((&lt; a 0) (cond ((&lt; y 0) (make-interval (* b x) (* a x)))
                         ((&lt; x 0) (make-interval (min (* a y) (* b x))
                                                 (max (* a x) (* b y))))
                         (else (mul-interval j i))))
          (else (cond ((&lt; y 0) (make-interval (* b x) (* a y)))
                      ((&lt; x 0) (make-interval (* b x) (* b y)))
                      (else (make-interval (* a x) (* b y))))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org65b76a0" class="outline-4">
<h4 id="org65b76a0">Exercise 2.12</h4>
<div class="outline-text-4" id="text-org65b76a0">
<div class="org-src-container">
<pre class="src src-scheme">(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))  
(define (make-center-percent c p)
  (make-center-width c (* c p)))
(define (percent i)
  (/ (width i) (center i)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb7796e4" class="outline-4">
<h4 id="orgb7796e4">Exercise 2.13</h4>
<div class="outline-text-4" id="text-orgb7796e4">
<p>
Let interval \(i\) have center \(c_{i}\) and tolerance \(p_{i}\). Let
interval \(j\) have center \(c_{j}\) and tolerance \(p_{j}\). Then \(i =
(c_{i}-c_{i}p_{i},c_{i}+c_{i}p_{i})\) and \(j =
(c_{j}-c_{j}p_{j},c_{j}+c_{j}p_{j})\). Suppose \(c_{i} > 0\) and \(c_{j} >
0\). Then \[i*j =
((c_{i}-c_{i}p_{i})*(c_{j}-c_{j}p_{j}),(c_{i}+c_{i}p_{i})*(c_{j}+c_{j}p_{j}))\]
\[= (c_{i}(1-p_{i})c_{j}(1-p_{j}),c_{i}(1+p_{i})c_{j}(1+p_{j}))\] \[=
(c_{i}c_{j}(1-p_{i})(1-p_{j}),c_{i}c_{j}(1+p_{i})(1+p_{j}))\] Supposing
small percentage tolerances: \[=
(c_{i}c_{j}(1-p_{i}-p_{j}),c_{i}c_{j}(1+p_{i}+p_{j}))\] Therefore \(i*j\)
is an interval centered at \(c_{i}c_{j}\) with tolerance
\(p_{i}+p_{j}\).
</p>
</div>
</div>
<div id="outline-container-orgc9bd86a" class="outline-4">
<h4 id="orgc9bd86a">Exercise 2.14</h4>
<div class="outline-text-4" id="text-orgc9bd86a">
<div class="org-src-container">
<pre class="src src-scheme">(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval one
                    (add-interval (div-interval one r1)
                                  (div-interval one r2)))))
</pre>
</div>
<p>
Let \(R_{1} = (a_{1},b_{1})\) and \(R_{2} = (a_{2},b_{2})\). Expanding, we
see: \[\frac{R_{1}R_{2}}{R_{1}+R_{2}} =
(\frac{a_{1}a_{2}}{b_{1}+b_{2}},\frac{b_{1}b_{2}}{a_{1}+a_{2}})\]
\[\frac{1}{\frac{1}{R_{1}}+\frac{1}{R_{2}}} =
(\frac{a_{1}a_{2}}{a_{1}+a_{2}},\frac{b_{1}b_{2}}{b_{1}+b_{2}})\] This
can be verified in the REPL.
</p>
</div>
</div>
</div>
<div id="outline-container-org0bb4fb3" class="outline-3">
<h3 id="org0bb4fb3">Section 2.2</h3>
<div class="outline-text-3" id="text-org0bb4fb3">
</div>
<div id="outline-container-org40719ab" class="outline-4">
<h4 id="org40719ab">Exercise 2.17</h4>
<div class="outline-text-4" id="text-org40719ab">
<div class="org-src-container">
<pre class="src src-scheme">(define (last-pair l)
  (if (null? (cdr l))
      l
      (last-pair (cdr l))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org54751ae" class="outline-4">
<h4 id="org54751ae">Exercise 2.18</h4>
<div class="outline-text-4" id="text-org54751ae">
<p>
Note that "nil" is no longer a part of the Scheme standard; we'll use
<kbd>()</kbd> instead. See this <a href="https://stackoverflow.com/questions/9115703/null-value-in-mit-scheme">stackoverflow post</a> for more.
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (reverse l)
  (define (helper in out)
    (if (null? in)
        out
        (helper (cdr in) (cons (car in) out))))
  (helper l ()))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb491b88" class="outline-4">
<h4 id="orgb491b88">Exercise 2.19</h4>
<div class="outline-text-4" id="text-orgb491b88">
<div class="org-src-container">
<pre class="src src-scheme">(define no-more? null?)
(define except-first-denomination cdr)
(define first-denomination car)
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))
</pre>
</div>
<p>
The order of the list coin-values still does not affect the
output because the procedure does not rely on any assumptions
regarding the order of coin-values.
</p>
</div>
</div>
<div id="outline-container-org8de135e" class="outline-4">
<h4 id="org8de135e">Exercise 2.20</h4>
<div class="outline-text-4" id="text-org8de135e">
<div class="org-src-container">
<pre class="src src-scheme">(define (same-parity? a b)
  (= (remainder a 2) (remainder b 2)))
(define (same-parity x . l)
  (define (filterer sublist)
    (cond ((null? sublist) sublist)
          ((same-parity? x (car sublist))
           (cons (car sublist) (filterer (cdr sublist))))
          (else (filterer (cdr sublist)))))
  (cons x (filterer l)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org3aea5c7" class="outline-4">
<h4 id="org3aea5c7">Exercise 2.21</h4>
<div class="outline-text-4" id="text-org3aea5c7">
<div class="org-src-container">
<pre class="src src-scheme">(define (square-list items)
  (if (null? items)
      items
      (cons (square (car items))
            (square-list (cdr items)))))
(define (square-list-map items)
  (map square items))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb4ea566" class="outline-4">
<h4 id="orgb4ea566">Exercise 2.22</h4>
<div class="outline-text-4" id="text-orgb4ea566">
<p>
Elements appearing first in the input list will be added to the head
of the ouput list before elements appearing later. Therefore, elements
appearing first in the input will appear later in the output.
</p>

<p>
Now, the output isn't a list.
</p>
</div>
</div>
<div id="outline-container-org11a3df7" class="outline-4">
<h4 id="org11a3df7">Exercise 2.23</h4>
<div class="outline-text-4" id="text-org11a3df7">
<div class="org-src-container">
<pre class="src src-scheme">(define (for-each f l)
  (if (not (null? l))
      (begin (f (car l))
             (for-each f (cdr l)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd108743" class="outline-4">
<h4 id="orgd108743">Exercise 2.25</h4>
<div class="outline-text-4" id="text-orgd108743">
<div class="org-src-container">
<pre class="src src-scheme">(define l1 (list 1 3 (list 5 7) 9))
(car (cdr (car (cdr (cdr l1)))))
(define l2 (list (list 7)))
(car (car l2))
(define l3 (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr l3))))))))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgda6a942" class="outline-4">
<h4 id="orgda6a942">Exercise 2.27</h4>
<div class="outline-text-4" id="text-orgda6a942">
<div class="org-src-container">
<pre class="src src-scheme">(define (deep-reverse l)
  (define (helper in out)
    (if (null? in)
        out
        (helper (cdr in) (cons (deep-reverse (car in)) out))))
  (if (list? l)
      (helper l ())
      l))
</pre>
</div>
</div>
</div>
<div id="outline-container-org002f5c2" class="outline-4">
<h4 id="org002f5c2">Exercise 2.28</h4>
<div class="outline-text-4" id="text-org002f5c2">
<div class="org-src-container">
<pre class="src src-scheme">(define (fringe tree)
  (cond ((not (list? tree)) (list tree))
        ((not (pair? tree)) tree)
        (else (append (fringe (car tree)) (fringe (cdr tree))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org18aab3e" class="outline-4">
<h4 id="org18aab3e">Exercise 2.29</h4>
<div class="outline-text-4" id="text-org18aab3e">
<div class="org-src-container">
<pre class="src src-scheme">(define (left-branch m) (car m))
(define (right-branch m) (car (cdr m)))
(define (branch-length b) (car b))
(define (branch-structure b) (car (cdr b)))
(define (mobile? structure) (pair? structure))
(define (branch-weight b)
  (let ((structure (branch-structure b)))
    (if (mobile? structure)
        (total-weight structure)
        structure)))   
(define (total-weight m)
  (+ (branch-weight (left-branch m))
     (branch-weight (right-branch m))))
(define (mobile-balanced? m)
  (define (branch-balanced? b)
    (let ((structure (branch-structure b)))
      (if (mobile? structure)
          (mobile-balanced? structure)
          #t)))
  (let ((left (left-branch m))
        (right (right-branch m)))
    (and (= (* (branch-length left) (branch-weight left))
            (* (branch-length right) (branch-weight right)))
         (branch-balanced? left)
         (branch-balanced? right))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf7488ae" class="outline-4">
<h4 id="orgf7488ae">Exercise 2.30</h4>
<div class="outline-text-4" id="text-orgf7488ae">
<div class="org-src-container">
<pre class="src src-scheme">(define (square-tree tree)
  (cond ((null? tree) tree)
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree (car tree))
                    (square-tree (cdr tree))))))
(define (square-tree-map tree)
  (map (lambda (subtree)
         (if (not (pair? subtree))
             (square subtree)
             (square-tree-map subtree)))
       tree))
</pre>
</div>
</div>
</div>
<div id="outline-container-org2e48277" class="outline-4">
<h4 id="org2e48277">Exercise 2.31</h4>
<div class="outline-text-4" id="text-org2e48277">
<div class="org-src-container">
<pre class="src src-scheme">(define (tree-map f t)
  (cond ((null? t) t)
        ((not (pair? t)) (f t))
        (else (cons (tree-map f (car t))
                    (tree-map f (cdr t))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org5aee4b3" class="outline-4">
<h4 id="org5aee4b3">Exercise 2.32</h4>
<div class="outline-text-4" id="text-org5aee4b3">
<p>
The procedure takes advantage of the following observation. If \(x\) is
an element of set \(S\) then we can partition the subsets of \(S\) into
two categories: those that contain \(x\) and those that do not. All of
the subsets that do not contain \(x\) can be found by recursively
finding all of the subsets of \(S \setminus {x}\). All of the subsets
that do contain \(x\) are of the form \(x \cup U\) where \(U \in \wp (S
\setminus {x})\).
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (subsets s)
  (if (null? s)
      (list ())
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (l) (cons (car s) l)) rest)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org3765fb4" class="outline-4">
<h4 id="org3765fb4">Exercise 2.33</h4>
<div class="outline-text-4" id="text-org3765fb4">
<div class="org-src-container">
<pre class="src src-scheme">(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) () sequence))
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
</pre>
</div>
</div>
</div>
<div id="outline-container-org0cf1e26" class="outline-4">
<h4 id="org0cf1e26">Exercise 2.34</h4>
<div class="outline-text-4" id="text-org0cf1e26">
<div class="org-src-container">
<pre class="src src-scheme">(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                (+ (* higher-terms x)
                   this-coeff))
              0
              coefficient-sequence))
</pre>
</div>
</div>
</div>
<div id="outline-container-org96a44bc" class="outline-4">
<h4 id="org96a44bc">Exercise 2.35</h4>
<div class="outline-text-4" id="text-org96a44bc">
<div class="org-src-container">
<pre class="src src-scheme">(define (count-leaves t)
  (accumulate +
              0
              (map (lambda (elt)
                     (if (pair? elt)
                         (count-leaves elt)
                         1))
                   t)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org8721684" class="outline-4">
<h4 id="org8721684">Exercise 2.36</h4>
<div class="outline-text-4" id="text-org8721684">
<div class="org-src-container">
<pre class="src src-scheme">(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      ()
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org74d857a" class="outline-4">
<h4 id="org74d857a">Exercise 2.37</h4>
<div class="outline-text-4" id="text-org74d857a">
<div class="org-src-container">
<pre class="src src-scheme">(define (dot-product v w)
  (accumulate + 0 (map * v w)))
(define (matrix-*-vector m v)
  (map (lambda (row)
         (dot-product row v))
       m))
(define (transpose mat)
  (accumulate-n cons () mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (row)
           (map (lambda (col)
                  (dot-product row col))
                cols))
         m)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org2d6aa1b" class="outline-4">
<h4 id="org2d6aa1b">Exercise 2.38</h4>
<div class="outline-text-4" id="text-org2d6aa1b">
<div class="org-src-container">
<pre class="src src-scheme">(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
(define fold-right accumulate)

(fold-right / 1 (list 1 2 3)) ; 3/2
(fold-left / 1 (list 1 2 3)) ; 1/6
(fold-right list () (list 1 2 3)) ; (1 (2 (3 ())))
(fold-left list () (list 1 2 3)) ; (((() 1) 2) 3)
</pre>
</div>
</div>
</div>
<div id="outline-container-org7652627" class="outline-4">
<h4 id="org7652627">Exercise 2.39</h4>
<div class="outline-text-4" id="text-org7652627">
<div class="org-src-container">
<pre class="src src-scheme">(define (reverse sequence)
  (fold-right (lambda (x y) (append y (list x))) () sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) (cons y x)) () sequence))
</pre>
</div>
</div>
</div>
<div id="outline-container-org6921f73" class="outline-4">
<h4 id="org6921f73">Exercise 2.40</h4>
<div class="outline-text-4" id="text-org6921f73">
<div class="org-src-container">
<pre class="src src-scheme">(define (enumerate-interval k)
  (define (iter curr result)
    (if (= curr 0)
        result
        (iter (- curr 1) (cons curr result))))
  (iter k ()))
(define (unique-pairs n)
  (flatmap (lambda (i)
             (map (lambda (j)
                    (list i j))
                  (enumerate-interval (- i 1))))
           (enumerate-interval n)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgafe7f97" class="outline-4">
<h4 id="orgafe7f97">Exercise 2.41</h4>
<div class="outline-text-4" id="text-orgafe7f97">
<div class="org-src-container">
<pre class="src src-scheme">;; This is slow...
(define (unique-tuples n max)
  (cond ((= n 0) (list ()))
        ((&lt; max n) ())
        ((= max n) (list (reverse (enumerate-interval n))))
        (else (append (unique-tuples n (- max 1))
                      (map (lambda (t)
                             (cons max t))
                           (unique-tuples (- n 1) (- max 1)))))))
;; (define (unique-tuples n max)
;;   (define (iter tuples)
;;     (if (= (length (car tuples)) 0)
;;         tuples
;;         (iter (flatmap (lambda (l)
;;                          (if))))))
;;   (if (&lt; max n)
;;       ()
;;       (flatmap values
;;                (iter (map list
;;                           (reverse (enumerate-interval n)))))))
;; ;; And this doesn't work...
;; (define (unique-tuples n max)
;;   (define (next-tuple tuple)
;;     (define (cons-next-tuple min t)
;;       (cond ((null? t) t)
;;             ((null? (cdr t)) t)
;;             ((= (car t) (- (cadr t) 1))
;;              (cons min (cons-next-tuple (+ min 1) (cdr t))))
;;             (else (cons (+ 1 (car t)) (cdr t)))))
;;     (cons-next-tuple 1 tuple))
;;   (define (iter t result)
;;     (if (&gt; (car t) max)
;;         result
;;         (iter (next-tuple t) (cons t result))))
;;   (iter (enumerate-interval n) ()))
(define (sum-list l)
  (fold-left + 0 l))
(define (bounded-partition n parts bound)
  (filter (lambda (t)
            (= n (sum-list t)))
          (unique-tuples parts bound)))
(define (bounded-paritition-3 total bound)
  (bounded-partition total 3 bound))
</pre>
</div>
</div>
</div>
<div id="outline-container-org0ff20ad" class="outline-4">
<h4 id="org0ff20ad">Exercise 2.42</h4>
<div class="outline-text-4" id="text-org0ff20ad">
<div class="org-src-container">
<pre class="src src-scheme">(define (make-queen row col)
  (list row col))
(define (get-row queen)
  (car queen))
(define (get-col queen)
  (cadr queen))
(define (queens board-size)
  (define (adjoin-position row col board)
    (cons (make-queen row col) board))
  (define (safe? col board)
    (define (same-diag? q1 q2)
      (= (difference (get-row q1) (get-row q2))
         (difference (get-col q1) (get-col q2))))
    (define (same-row? q1 q2)
      (= (get-row q1) (get-row q2)))
    (let ((new-queen (car board)))
      (fold-right (lambda (x y) (and x y))
                  #t
                  (map (lambda (q)
                         (and (not (same-row? new-queen q))
                              (not (same-diag? new-queen q))))
                       (cdr board)))))
  (define empty-board ())
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
(define (repeat-display n str)
  (if (&gt; n 0)
      (begin
        (display str)
        (whitespace (- n 1)))))
(define (print-queens board)
  (define (iter left)
    (if (not (null? left))
        (let ((row (get-row (car left))))
          (repeat-display (- row 1) ".")
          (display "Q")
          (repeat-display (- (length board) row) ".")
          (newline)
          (iter (cdr left)))))
  (iter board))
(define (show-queens n)
  (map (lambda (soln)
         (print-queens soln)
         (newline))
       (queens n)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbd0da25" class="outline-4">
<h4 id="orgbd0da25">Exercise 2.43</h4>
<div class="outline-text-4" id="text-orgbd0da25">
<p>
In the provided <kbd>queens</kbd> procedure, the \(n \times (k-1)\) subproblem is
solved once. Then, for each solution of the subproblem, several
candidate solutions for the \(n \times k\) problem are created by adding
a new column with a queen in each possible row.
</p>

<p>
Louis's procedure calculates each possible row once (in the call to
<kbd>enumerate-interval</kbd>). Then, for each row, the procedure calculates
the \(n \times (k-1)\) subproblem. So, at each level of the process, the
subproblem is solved \(n\) times. Therefore, in Louis' procedure, the
base-case \(n \times 0\) problem, computed by <kbd>(queens 0)</kbd>, is
calculated \(n^{n}\) times. Louis' procedure solves the puzzle in
approximately time \(n^{n}T\).
</p>
</div>
</div>
<div id="outline-container-orgf614b83" class="outline-4">
<h4 id="orgf614b83">Exercise 2.44</h4>
<div class="outline-text-4" id="text-orgf614b83">
<div class="org-src-container">
<pre class="src src-scheme">(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org4d8e5ce" class="outline-4">
<h4 id="org4d8e5ce">Exercise 2.45</h4>
<div class="outline-text-4" id="text-org4d8e5ce">
<div class="org-src-container">
<pre class="src src-scheme">(define (split outer inner)
  (lambda (painter n)
    (if (= n 0)
        painter
        (let ((smaller ((split outer inner) painter (- n 1))))
          (outer painter (inner smaller smaller))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org114f751" class="outline-4">
<h4 id="org114f751">Exercise 2.46</h4>
<div class="outline-text-4" id="text-org114f751">
<div class="org-src-container">
<pre class="src src-scheme">(define (make-vect x y) (cons x y))
(define (xcor-vect v) (car v))
(define (ycor-vect v) (cdr v))
(define (add-vect v1 v2) )
</pre>
</div>
<p>
I'll leave this exercise here.
</p>
</div>
</div>
<div id="outline-container-orga27c5e3" class="outline-4">
<h4 id="orga27c5e3">Exercise 2.47</h4>
<div class="outline-text-4" id="text-orga27c5e3">
<div class="org-src-container">
<pre class="src src-scheme">(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (origin-frame frame)
  (car frame))
(define (edge1-frame frame)
  (cadr frame))
(define (edge2-frame frame)
  (caddr frame))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-scheme">(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
(define (origin-frame frame)
  (car frame))
(define (edge1-frame frame)
  (cadr frame))
(define (edge2-frames frame)
  (cddr frame))
</pre>
</div>
</div>
</div>
<div id="outline-container-org55a0b11" class="outline-4">
<h4 id="org55a0b11">Exercise 2.48</h4>
<div class="outline-text-4" id="text-org55a0b11">
<div class="org-src-container">
<pre class="src src-scheme">(define (make-segment v1 v2)
  (cons v1 v2))
(define (start-segment v) (car v))
(define (end-segment v) (cdr v))
</pre>
</div>
</div>
</div>
<div id="outline-container-orge1371db" class="outline-4">
<h4 id="orge1371db">Exercise 2.49</h4>
<div class="outline-text-4" id="text-orge1371db">
<div class="org-src-container">
<pre class="src src-scheme">(define (fold-right op null l)
  (if (null? l)
      null
      (op (car l) (fold-right op null (cdr l)))))
(define (fold-left-iter op null l)
  (define (iter curr result)
    (if (null? curr)
        result
        (iter (cdr curr) (op result (car curr)))))
  (iter l null))
(define (take n l)
  (if (= n 0)
      ()
      (cons (car l) (take (- n 1) (cdr l)))))
(define (rotate-left l n)
  (fold-right cons
              (take n l)
              ((repeated cdr n) l)))
(define (outline f)
  (segments-&gt;painter
   (let ((rotl (lambda (l) (fold-right cons (list (car l)) (cdr l)))))
     (let ((x-cors (list 0 0 1 1)))
       (let ((corners (map make-vect x-cors (rotl x-cors))))
         (map make-segment
              corners
              (rotl corners)))))))
(define (x-painter f)
  (segments-painter
   (map make-segment
        (map make-vect
             (list 0 0)
             (list 0 1))
        (map make-vect
             (list 1 1)
             (list 1 0)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org8997f51" class="outline-4">
<h4 id="org8997f51">Exercise 2.51</h4>
<div class="outline-text-4" id="text-org8997f51">
<div class="org-src-container">
<pre class="src src-scheme">(define (below p1 p2)
  (rotate90 (beside (rotate270 p2)
                    (rotate270 p1))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6d27cc0" class="outline-3">
<h3 id="org6d27cc0">Section 2.3</h3>
<div class="outline-text-3" id="text-org6d27cc0">
</div>
<div id="outline-container-orgd8eb0eb" class="outline-4">
<h4 id="orgd8eb0eb">Exercise 2.53</h4>
<div class="outline-text-4" id="text-orgd8eb0eb">
<div class="org-src-container">
<pre class="src src-scheme">(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))
</pre>
</div>
</div>
</div>
<div id="outline-container-org0ff2104" class="outline-4">
<h4 id="org0ff2104">Exercise 2.54</h4>
<div class="outline-text-4" id="text-org0ff2104">
<div class="org-src-container">
<pre class="src src-scheme">(define (equal? a b)
  (if (and (pair? a) (pair? b))
      (and (equal? (car a) (car b))
           (equal? (cdr a) (cdr b)))
      (eq? a b)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org18e7ecf" class="outline-4">
<h4 id="org18e7ecf">Exercise 2.55</h4>
<div class="outline-text-4" id="text-org18e7ecf">
<p>
Eva types <kbd>(car ''abracadabra)</kbd> and the interpreter prints
<kbd>quote</kbd>. A footnote mentions that <kbd>'</kbd> is implemented as procedure
application, and so <kbd>(car ''abracadabra)</kbd> is evaluated to <kbd>(car (quote
(quote abracadabra)))</kbd>. Then it makes sense for <kbd>car</kbd> of <kbd>(quote
abracadabra)</kbd> to be <kbd>quote</kbd>. To verify this we run the following:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(cdr ''abracadabra)
abracadabra
</pre>
</div>
<p>
This is consistent with our explanation.
</p>
</div>
</div>
<div id="outline-container-orgbd2a918" class="outline-4">
<h4 id="orgbd2a918">Exercise 2.56</h4>
<div class="outline-text-4" id="text-orgbd2a918">
<p>
The provided code:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-product m1 m2) (list '* m1 m2))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        (else
         (error "unknown expression type -- DERIV" exp))))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-scheme">(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))
(define (base e) (cadr e))
(define (exponent e) (caddr e))
(define (make-exponentiation b p)
  (cond ((=number? p 0) 1)
        ((=number? p 1) b)
        ((and (number? b) (number? p)) (expt b p))
        (else (list '** b p))))
(define (make-difference a b)
  (make-sum a (make-product b -1)))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (make-product
          (exponent exp)
          (make-product (make-exponentiation
                         (base exp)
                         (make-difference (exponent exp)
                                          1))
                        (deriv (base exp) var))))
        (else
         (error "unknown expression type -- DERIV" exp))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orga2fa15d" class="outline-4">
<h4 id="orga2fa15d">Exercise 2.57</h4>
<div class="outline-text-4" id="text-orga2fa15d">
<div class="org-src-container">
<pre class="src src-scheme">(define (augend s)
  (if (null? (cdddr s))
      (caddr s)
      (cons '+ (cddr s))))
(define (make-sum a b)
  (let* ((flat (flatmap (lambda (t) (if (sum? t) (cdr t) t))
                        (list a b)))
         (sum (foldl + 0 (filter number? flat)))
         (rest (filter! number? flat)))
    (cond ((null? rest) sum)
          ((= sum 0) (if (null? (cdr rest)) (car rest) (cons '+ rest)))
          (else (cons '+ (cons acc rest))))))
(define (multiplicand p)
  (if (null? (cdddr p))
      (caddr p)
      (cons '* (cddr p))))
(define (make-product a b)
  (let* ((flat (flatmap (lambda (t) (if (sum? t) (cdr t) t))
                        (list a b)))
         (prod (foldl * 1 (filter number? flat)))
         (rest (filter! number? flat)))
    (cond ((null? rest) prod)
          ((= sum 1) (if (null? (cdr rest)) (car rest) (cons '+ rest)))
          ((= sum 0) 0)
          (else (cons '+ (cons acc rest))))))
</pre>
</div>
<p>
I tried to refactor <kbd>make-sum</kbd> and <kbd>make-product</kbd> into a simpler yet
meaningful-enough function, to no avail. I'll heed the <a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)">rule of three</a>
for now.
</p>
</div>
</div>
<div id="outline-container-org7c646da" class="outline-4">
<h4 id="org7c646da">Exercise 2.58</h4>
<div class="outline-text-4" id="text-org7c646da">
<ol class="org-ol">
<li><p>
Infix addition:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (sum? e)
  (and (pair? e)
       (pair? (cdr e))
       (eq? (cadr e) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list a1 '+ a2))))
</pre>
</div>
<p>
The same modifications apply to <kbd>product?</kbd>, <kbd>multiplier</kbd>,
<kbd>multiplicand</kbd>, and <kbd>make-product</kbd>, mutatis mutandis.
</p></li>
<li>Each element in a given list is a number, a variable, a sum, a
product, or a parenthesized expression. If a list has more than one
element, it must by a product or a sum. If the list contains both
<kbd>+</kbd> and <kbd>*</kbd>, such as <kbd>(x + 3 * y)</kbd> then the list represents a sum,
because <kbd>*</kbd> binds tighter than <kbd>+</kbd>. Therefore, if the list contains
even one <kbd>+</kbd> then we can consider the expression to the left of the
first <kbd>+</kbd> the addend and the expression to the right the augend. If
a list that has more than one element is not a sum, then it must be
a product.</li>
</ol>
</div>
</div>
<div id="outline-container-orgb8057a0" class="outline-4">
<h4 id="orgb8057a0">Exercise 2.59</h4>
<div class="outline-text-4" id="text-orgb8057a0">
<p>
Provided code:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-scheme">(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (else (adjoin-set (car set1) (union-set (cdr set1) set2)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd2afece" class="outline-4">
<h4 id="orgd2afece">Exercise 2.60</h4>
<div class="outline-text-4" id="text-orgd2afece">
<div class="org-src-container">
<pre class="src src-scheme">(define (element-of-set? x set) (memq x set))
(define (adjoin-set x set) (cons x set))
(define (union-set set1 set2) (append set1 set2))
(define (intersection-set set1 set2)
  (filter (lambda (x) (element-of-set? x set2)) set1))
</pre>
</div>
<p>
<kbd>element-of-set?</kbd> is still an \(O(n)\) operation; there's no getting
around this. But <kbd>adjoin-set</kbd> is now an \(O(1)\) operation, and
<kbd>union-set</kbd>, which is \(O(n^{2})\) in my implementation above, is now
\(O(n)\). <kbd>intersection-set</kbd> is still an \(O(n^{2})\) operation.
</p>
</div>
</div>
<div id="outline-container-org968af46" class="outline-4">
<h4 id="org968af46">Exercise 2.61</h4>
<div class="outline-text-4" id="text-org968af46">
<div class="org-src-container">
<pre class="src src-scheme">(define (adjoin-set x set)
  (cond ((null? set) (cons x set))
        ((&gt; x (car set)) (cons (car set) (adjoin-set x (cdr set))))
        ((= x (car set)) set)
        (else (cons x set))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org0ee4bc4" class="outline-4">
<h4 id="org0ee4bc4">Exercise 2.62</h4>
<div class="outline-text-4" id="text-org0ee4bc4">
<div class="org-src-container">
<pre class="src src-scheme">(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (else (let ((x1 (car set1))
                    (x2 (car set2)))
                (cond ((= x1 x2)
                       (cons x1 (union-set (cdr set1)
                                           (cdr set2))))
                      ((&lt; x1 x2)
                       (cons x1 (union-set (cdr set1)
                                           set2)))
                      ((&gt; x1 x2)
                       (cons x2 (union-set set1
                                           (cdr set2)))))))))
</pre>
</div>
<p>
&lt;s
</p>
</div>
</div>
<div id="outline-container-orga498e6b" class="outline-4">
<h4 id="orga498e6b">Exercise 2.63</h4>
<div class="outline-text-4" id="text-orga498e6b">
<p>
The trees from<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-16.html#%25_fig_2.16"> Figure 2.16</a>:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define tree-a
  (make-tree
   7
   (make-tree
    3
    (make-tree 1 () ())
    (make-tree 5 () ()))
   (make-tree
    9
    ()
    (make-tree 11 () ()))))
(define tree-b
  (make-tree
   3
   (make-tree 1 () ())
   (make-tree
    7
    (make-tree 5 () ())
    (make-tree
     9
     ()
     (make-tree 11 () ())))))
(define tree-c
  (make-tree
   5
   (make-tree
    3
    (make-tree 1 () ())
    ())
   (make-tree
    9
    (make-tree 7 () ())
    (make-tree 11 () ()))))
</pre>
</div>
<ol class="org-ol">
<li><kbd>tree-&gt;list-1</kbd> and <kbd>tree-&gt;list-2</kbd> result in <kbd>(1 3 5 7 9 11)</kbd> for
every tree above. Moreover, <kbd>tree-&gt;list-1</kbd> and <kbd>tree-&gt;list-2</kbd>
produce the same result for for any two trees that represent the same
set.</li>
<li><p>
<kbd>tree-&gt;list-1</kbd> uses <kbd>append</kbd> to combine the solutions to the
recursively-solved subproblems. This procedure takes time
proportional to the size of its first input, namely the left
subtree of any given node.
</p>

<p>
Suppose we have a balanced tree of \(n = 2^{k}-1\) nodes (meaning
that \(k\) is the number of levels in the tree). Level \(i\) of the
tree (call the root level \(0\)) has \(2^{i}\) nodes. Each of these
nodes combines its subproblems in time proportional to the size of
its left subtree, which is \(2^{k-i-1}\). The total time of the tree
is therefore proportional to the following: \[\sum_{i=0}^{k-1}
   2^{i}2^{k-i-1} = \sum_{i=0}^{k-1} 2^{k-1} = k2^{k-1} =
   k\frac{n+1}{2} = \log(n+1)\frac{n+1}{2}\] Therefore the order of
growth of <kbd>tree-&gt;list-1</kbd> is \(O(n\log(n))\).
</p>

<p>
Perhaps a simpler formula:
\[\frac{n}{2}+2\frac{n}{4}+4\frac{n}{8}+\ldots\]
\[\frac{n}{2}+\frac{n}{2}+\frac{n}{2}+\ldots\]
\[\log(n)\frac{n}{2}\]
</p>

<p>
On the other hand, <kbd>tree-&gt;list-2</kbd> uses <kbd>cons</kbd> to combine
subproblems, and therefore take \(O(1)\) time for each of the \(n\)
nodes in the tree, for a total of \(O(n)\) time.
</p></li>
</ol>
</div>
</div>
<div id="outline-container-orgab31bf6" class="outline-4">
<h4 id="orgab31bf6">Exercise 2.64</h4>
<div class="outline-text-4" id="text-orgab31bf6">
<ol class="org-ol">
<li><kbd>partial-tree</kbd> recurses once left and once right at each node to
build the tree. Therefore each of the \(n\) elements is tree-ified by
one call to <kbd>partial-tree</kbd>. All of the operations <kbd>partial-tree</kbd>
used to combine the solutions to the subproblems are \(O(1)\),
therefore <kbd>partial-tree</kbd> takes \(O(n)\) time.</li>
</ol>
</div>
</div>
<div id="outline-container-org2c777e2" class="outline-4">
<h4 id="org2c777e2">Exercise 2.65</h4>
<div class="outline-text-4" id="text-org2c777e2">
<div class="org-src-container">
<pre class="src src-scheme">(define (union-set set1 set2)
  (list-&gt;tree (union-set-list (tree-&gt;list-2 set1)
                              (tree-&gt;list-2 set2))))
</pre>
</div>
<p>
Mutatis mutandis for <kbd>intersection-set</kbd>.
</p>
</div>
</div>
<div id="outline-container-org0ae9a1e" class="outline-4">
<h4 id="org0ae9a1e">Exercise 2.67</h4>
<div class="outline-text-4" id="text-org0ae9a1e">
<p>
<kbd>(a d a b b c a)</kbd>
</p>
</div>
</div>
<div id="outline-container-orgb0de37b" class="outline-4">
<h4 id="orgb0de37b">Exercise 2.68</h4>
<div class="outline-text-4" id="text-orgb0de37b">
<div class="org-src-container">
<pre class="src src-scheme">(define (encode-symbol symbol tree)
  (define (encode-1 bits branch)
    (if (leaf? branch)
        bits
        (let ((left (left-branch branch)))
          (if (memq symbol (symbols left))
              (encode-1 (cons 0 bits) left)
              (encode-1 (cons 1 bits) (right-branch branch))))))
  (if (memq symbol (symbols tree))
      (reverse (encode-1 () tree))
      (error "not in tree")))
</pre>
</div>
</div>
</div>
<div id="outline-container-org60662c4" class="outline-4">
<h4 id="org60662c4">Exercise 2.69</h4>
<div class="outline-text-4" id="text-org60662c4">
<div class="org-src-container">
<pre class="src src-scheme">(define (successive-merge tree-set)
  (cond ((null? tree-set) ())
        ((null? (cdr tree-set)) (car tree-set))
        (else
         (successive-merge (adjoin-set (make-code-tree (car tree-set)
                                                       (cadr tree-set))
                                       (cddr tree-set))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org01b9cb8" class="outline-4">
<h4 id="org01b9cb8">Exercise 2.70</h4>
<div class="outline-text-4" id="text-org01b9cb8">
<div class="org-src-container">
<pre class="src src-scheme">(length (encode '(GET A JOB
                  SHA NA NA NA NA NA NA NA NA
                  GET A JOB
                  SHA NA NA NA NA NA NA NA NA
                  WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP
                  SHA BOOM)
                (generate-huffman-tree
                 '((A 2) (NA 16)
                   (BOOM 1) (SHA 3)
                   (GET 2) (YIP 9)
                   (JOB 2) (WAH 1)))))
;Value: 84
</pre>
</div>
<p>
A fixed-length code would take at least 3 bits per symbol times 36
symbols for a total of 108 bits.
</p>
</div>
</div>
<div id="outline-container-org374a906" class="outline-4">
<h4 id="org374a906">Exercise 2.71</h4>
<div class="outline-text-4" id="text-org374a906">
<p>
The trees look like lists: each non-leaf node has one leaf child and
one non-leaf child. The most frequent symbol takes one bit, and the
least frequent symbol takes \(n-1\) bits.
</p>
</div>
</div>
<div id="outline-container-org06d06ef" class="outline-4">
<h4 id="org06d06ef">Exercise 2.72</h4>
<div class="outline-text-4" id="text-org06d06ef">
<p>
If the relative frequencies are as described in exercise 2.71, then
the <kbd>memq</kbd> call in <kbd>encode-1</kbd> searches a list of length one at each
node, which is a constant-time operation. Therefore each of the \(n\)
iterations (in the worst case) of <kbd>encode-1</kbd> are
constant-time. Therefore <kbd>encode-1</kbd> has growth \(O(n)\). <kbd>reverse</kbd> and
the <kbd>memq</kbd> call in <kbd>encode</kbd> also have growth \(O(n)\), so <kbd>encode</kbd> has
time-complexity \(O(n)\) where \(n\) is the number of symbols in the
alphabet.
</p>
</div>
</div>
</div>
<div id="outline-container-org7c3e17c" class="outline-3">
<h3 id="org7c3e17c">Section 2.4</h3>
<div class="outline-text-3" id="text-org7c3e17c">
</div>
<div id="outline-container-org6da81a1" class="outline-4">
<h4 id="org6da81a1">Exercise 2.73</h4>
<div class="outline-text-4" id="text-org6da81a1">
<div class="org-src-container">
<pre class="src src-scheme">(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp)) (operands exp)
               var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
</pre>
</div>
<ol class="org-ol">
<li></li>
</ol>
<div class="org-src-container">
<pre class="src src-scheme">(define (install-prefix-system)
  (define (deriv-sum sum)
    (make-sum (deriv (addend exp) var)
              (deriv (augend exp) var)))
  (define (deriv-product prod)
    (make-sum
     (make-product (multiplier exp)
                   (deriv (multiplicand exp) var))
     (make-product (deriv (multiplier exp) var)
                   (multiplicand exp))))
  (put 'deriv '+ deriv-sum)
  (put 'deriv '* deriv-product))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc1076c0" class="outline-3">
<h3 id="orgc1076c0">Section 2.5</h3>
<div class="outline-text-3" id="text-orgc1076c0">
</div>
<div id="outline-container-org28d0c90" class="outline-4">
<h4 id="org28d0c90">Exercise 2.77</h4>
<div class="outline-text-4" id="text-org28d0c90">
<p>
<kbd>magnitude</kbd> was already defined in 2.4.3 as:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (magnitude z) (apply-generic 'magnitude z))
</pre>
</div>
<p>
This was done to provide a generic interface for getting the magnitude
of a complex number whether it's represented in rectangular or polar
coordinates. A function taking a complex number tagged with
<kbd>'polar</kbd> and a function taking a complex number tagged with
<kbd>'rectangular</kbd> were already added to the table.
</p>
</div>
</div>
<div id="outline-container-orgf09d96e" class="outline-4">
<h4 id="orgf09d96e">Exercise 2.78</h4>
<div class="outline-text-4" id="text-orgf09d96e">
<div class="org-src-container">
<pre class="src src-scheme">(define (attach-tag type-tag contents)
  (if (eq? type-tag 'scheme-number)
      contents
      (cons type-tag contents)))
(define (type-tag datum)
  (cond ((number? datum) 'scheme-number)
        ((pair? datum) (car datum))
        (else (error "Bad tagged datum -- TYPE-TAG" datum))))
(define (contents datum)
  (cond ((number? datum) datum)
        ((pair? datum) (cdr datum))
        (else (error "Bad tagged datum -- CONTENTS" datum))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org8a31936" class="outline-4">
<h4 id="org8a31936">Exercise 2.79</h4>
<div class="outline-text-4" id="text-org8a31936">
<p>
The following solution tests equality of numbers in the arithmetic
package that have the same type. For a more general approach that
allows compation numbers with different types, see Exercise 2.85.
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (equ?-num a b) (= a b))
(put 'equ? '(scheme-number scheme-number) equ?-num)
(define (equ?-rat a b) (and (= (numer a) (numer b))
                            (= (denom a) (denom b))))
(put 'equ? '(rational rational) equ?-rat)
(define (equ?-complex a b) (and (= (real-part a) (real-part b))
                                (= (imag-part a) (imag-part b))))
(put 'equ? '(complex complex) equ?-complex)
(define (equ? a b) (apply-generic 'equ? a b))
</pre>
</div>
<p>
With the current implementation of complex and rational numbers as
pairs of scheme numbers, using <kbd>=</kbd> within <kbd>equ?-rat</kbd> and
<kbd>equ?-complex</kbd> should work. But because <kbd>equ?</kbd> works with
scheme-numbers too, recursively testing the components of complex and
rational numbers by replacing <kbd>=</kbd> with <kbd>equ?</kbd> in <kbd>equ?-rat</kbd> and
<kbd>equ?-complex</kbd> will also work with future representations of complex
and rational numbers that internally use numbers from our number
package&#x2026;
</p>
</div>
</div>
<div id="outline-container-org148957c" class="outline-4">
<h4 id="org148957c">Exercise 2.80</h4>
<div class="outline-text-4" id="text-org148957c">
<div class="org-src-container">
<pre class="src src-scheme">(define (=zero? x) (apply-generic '=zero? x))
(put '=zero? '(scheme-number) (lambda (x) (= x 0)))
(define (=zero?-complex x)
  (= (magnitude x) 0))
(put '=zero? '(complex) =zero?-complex)
(define (=zero?-rat x)
  (= (numer x) 0))
(put '=zero?-rat '(rational) =zero?-rat)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfc16353" class="outline-4">
<h4 id="orgfc16353">Exercise 2.81</h4>
<div class="outline-text-4" id="text-orgfc16353">
<ol class="org-ol">
<li>Infinite recursion: <kbd>apply-generic</kbd> coerces the first complex
number to a complex number, and calls itself.</li>
<li><p>
Code:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (eq? type1 type2)
                    (error "No method for these types"
                           (list op type-tags))
                    (let ((t1-&gt;t2 (get-coercion type1 type2))
                          (t2-&gt;t1 (get-coercion type2 type1)))
                      (cond (t1-&gt;t2
                             (apply-generic op (t1-&gt;t2 a1) a2))
                            (t2-&gt;t1
                             (apply-generic op a1 (t2-&gt;t1 a2)))
                            (else
                             (error "No method for these types"
                                    (list op type-tags)))))))
              (error "No method for these types"
                     (list op type-tags)))))))
</pre>
</div></li>
</ol>
</div>
</div>
<div id="outline-container-org10c2472" class="outline-4">
<h4 id="org10c2472">Exercise 2.82</h4>
<div class="outline-text-4" id="text-org10c2472">
<p>
Imagine an arithmetic package for complex, real, and imaginary
numbers. Both real and imaginary numbers are subtypes of complex
numbers, but real and imaginary numbers are unrelated to each
other. If one tried to <kbd>add</kbd> a real number and a complex number, this
would only be possible if each was converted (raised) to a complex
number. With the current type-coercion algorithm, this is not possible.
</p>

<p>
One way to approach a fully general coercion system for two arguments
would be to determine all possible types that the first argument can
be coerced into, and, for each of these types, coerce the first
argument and retry the operation with each of the possible types of
the second argument in turn.
</p>

<p>
After thinking about this for a while, I do not know enough about the
use case to make a satisfactory general procedure. I can imagine
situations where:
</p>
<ul class="org-ul">
<li>The arguments can be coereced into new types in multiple valid
ways. Which coercions should be preferred?</li>
<li>The arguments can be "downcast". For example, a quadrilateral may
happen to be a square, and so it is valid to coerce such a
quadrilateral into a square. Should implicit coercion be allowed
here?</li>
<li>The only coercion that allows the operation to succeed requires that
an argument be coerced into a distant type. Should such coercion
happen automatically, or require that the caller be more explicit?</li>
</ul>

<p>
Instead, we will try the more naive method suggested in the exercise:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (define (fail) (error "No method for these types"
                          (list op type-tags)))
    (define (try-coerce targets)
      (if (null? targets)
          (fail)
          (let* ((targ (car targets))
                 (funcs (filter! null?
                                 (map (lambda (type) (get-coercion type targ))
                                      type-tags))))
            (if (= (length funcs) (length args))
                (let ((proc (get op (repeat (length args) targ))))
                  (if proc
                      (apply proc (map contents (map apply
                                                     funcs
                                                     (map list args))))
                      (try-coerce (cdr targets))))))))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (let ((all-types (remove-duplicates type-tags)))
            (if (length-1 all-types)
                (fail)
                (try-coerce all-types)))))))
</pre>
</div>
<p>
Usually, circular inheritance does not make sense. Therefore there
cannot be cycles in a general graph of type relationships. Therefore,
given two types a and b, at most one type can be an ancestor of the
other. If downcasting is to be explicit, then method of attempting to
coerce all of the args into the type of the first arg, then the second
arg, etc. is equivalent to attempting to coerce all of the args into
the type of the arg with the highest type in the hierarchy (because
all of the coercions that attempt to coerce the arg with the highest
type to any lower type will fail because we've said downcasting is
explicit).
</p>
</div>
</div>
<div id="outline-container-org4a89343" class="outline-4">
<h4 id="org4a89343">Exercise 2.83</h4>
<div class="outline-text-4" id="text-org4a89343">
<div class="org-src-container">
<pre class="src src-scheme">(define (int-&gt;rat int)
  (make-rational int 1))
(put 'raise 'int int-&gt;rat)
(define (rat-&gt;real rat)
  (make-real (/ (numer rat) (denom rat))))
(put 'raise 'rat rat-&gt;real)
(define (real-&gt;complex real)
  (make-complex-real-imag real 0))
(put 'raise 'real raise-real)
(define (raise num)
  ((get 'raise (type-tag num)) (contents num)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org2762a4b" class="outline-4">
<h4 id="org2762a4b">Exercise 2.84</h4>
<div class="outline-text-4" id="text-org2762a4b">
<div class="org-src-container">
<pre class="src src-scheme">(define (ancestor? arg1 arg2)
  (let ((func (get 'raise (tag arg2))))
    (if func
        (let ((super (func (contents arg2))))
          (if (= (tag super) (tag arg1))
              super
              (ancestor? arg1 super)))
        #f)))
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((a1 (car args))
                    (a2 (cadr args)))
                (let ((a2-&gt;type1 (ancestor? a1 a2))
                      (a1-&gt;type2 (ancestor? a2 a1)))
                  (cond (a2-&gt;type1
                         (apply-generic op a1 a2-&gt;type1))
                        (a1-&gt;type2
                         (apply-generic op a1-&gt;type2 a2))
                        (else
                         (error "No method for these types"
                                (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org04aff87" class="outline-4">
<h4 id="org04aff87">Exercise 2.85</h4>
<div class="outline-text-4" id="text-org04aff87">
<div class="org-src-container">
<pre class="src src-scheme">(define (project-complex complex)
  (make-real (real-part complex)))
(put 'project 'complex 'project-complex)
(define (project-real real)
  (make-rat (round real) 1))
(put 'project 'real 'project-real)
(define (project-rat rat)
  (make-int (round (/ (numer rat) (denom rat)))))
(put 'project 'rat 'project-rat)
(define (project num) (apply-generic 'project num))
(define (drop num)
  (if (get 'project (type-tag num))
      (let ((projection (project num)))
        (if (equ? num (raise projection))
            (drop (projection))
            num))
      num))
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (drop (apply proc (map contents args)))
          (if (= (length args) 2)
              (let ((a1 (car args))
                    (a2 (cadr args)))
                (let ((a2-&gt;type1 (ancestor? a1 a2))
                      (a1-&gt;type2 (ancestor? a2 a1)))
                  (cond (a2-&gt;type1
                         (apply-generic op a1 a2-&gt;type1))
                        (a1-&gt;type2
                         (apply-generic op a1-&gt;type2 a2))
                        (else
                         (error "No method for these types"
                                (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orga0b4f5e" class="outline-4">
<h4 id="orga0b4f5e">Exercise 2.86</h4>
<div class="outline-text-4" id="text-orga0b4f5e">
<p>
Depending on whether we want to store complex numbers internally as
rational numbers (or other future numbers), or just to handle making
complex numbers from rational numbers (or other future numbers) we
would need to:
</p>
<ul class="org-ul">
<li>Make both of the <kbd>make-complex-from-</kbd> procedures generic</li>
<li>Replace <kbd>+</kbd>, <kbd>-</kbd>, <kbd>*</kbd>, and <kbd>/</kbd> with <kbd>add</kbd>, <kbd>sub</kbd>, <kbd>mul</kbd>, and <kbd>div</kbd>
in internal procedures <kbd>add-complex</kbd>, <kbd>sub-complex</kbd>, etc</li>
<li>Rewrite polar- and rectangular- complex-number pacakges to use
generic procedures <kbd>sine</kbd>, <kbd>cosine</kbd>, <kbd>atangent</kbd>, <kbd>sqrt</kbd>, <kbd>plus</kbd></li>
<li>Rewrite <kbd>project-complex</kbd> and <kbd>raise-complex</kbd></li>
</ul>
</div>
</div>
<div id="outline-container-orgf1a8230" class="outline-4">
<h4 id="orgf1a8230">Exercise 2.87</h4>
<div class="outline-text-4" id="text-orgf1a8230">
<p>
Because <kbd>=zero?</kbd> is used in <kbd>adjoin-term</kbd>, zero coefficients are left
out of polynomials constructed with <kbd>add</kbd> and <kbd>mul</kbd>. If we rewrite
<kbd>make-poly</kbd> so that terms with zero coefficients are not actually
stored, then any polynomial that can be created will not no terms with
zero coefficients. Therefore the zero polynomial will simply have no
terms:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(put '=zero? 'poly empty-termlist?)
</pre>
</div>
</div>
</div>
<div id="outline-container-org722c093" class="outline-4">
<h4 id="org722c093">Exercise 2.88</h4>
<div class="outline-text-4" id="text-org722c093">
<div class="org-src-container">
<pre class="src src-scheme">(define (neg-poly poly)
  (define (neg-terms terms)
    (if (empty-termlist? terms)
        terms
        (let ((first (first-term terms)))
          (adjoin-term (make-term (order first)
                                  (neg (coeff first)))
                       (neg-terms (rest-terms terms))))))
  (make-poly (variable poly)
             (neg-terms (term-list poly))))
(put 'neg 'poly neg-poly)
(define (sub-poly p1 p2) (add-poly p1 (neg p2)))
(put 'sub 'poly sub-poly)
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p>hi</p>
</div>
</body>
</html>
