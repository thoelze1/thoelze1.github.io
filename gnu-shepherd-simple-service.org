#+TITLE: Writing a basic service for GNU Guix

Let's write a service for GNU Guix that will automatically start
[[https://github.com/kmonad/kmonad][kmonad]] at boot, and keep it running until shutdown.

Before we proceed, note that we could make a daemon of kmonad without
going to the trouble of writing a Guix-specific daemon: we could start
kmonad in a shell profile, write a cron job, or something else. The
user experience of these methods might be the same, but writing a
service keeps things organized and seems like the "right" way. If
nothing else, it's a great learning opportunity.

First let's read the documentation of [[https://guix.gnu.org/en/manual/en/guix.html][GNU Guix]]. We see that Guix
offers "services" which extend the functionality of the operating
system. The manual says:

#+begin_quote
Guix system services are connected by extensions. For instance, the
secure shell service extends the Shepherd—the initialization system,
running as PID 1—by giving it the command lines to start and stop the
secure shell daemon (see openssh-service-type); the UPower service
extends the D-Bus service by passing it its .service specification,
and extends the udev service by passing it device management rules
(see upower-service); the Guix daemon service extends the Shepherd by
passing it the command lines to start and stop the daemon, and extends
the account service by passing it a list of required build user
accounts (see Base Services).
#+end_quote

This sounds like what we want. Below, we see that the Guix daemon
defines its own "service type":

#+begin_src scheme
(define guix-service-type
  (service-type
   (name 'guix)
   (extensions
    (list (service-extension shepherd-root-service-type guix-shepherd-service)
          (service-extension account-service-type guix-accounts)
          (service-extension activation-service-type guix-activation)))
   (default-value (guix-configuration))))
#+end_src

Hm. I didn't expect we'd need to instatiate our own data type just to
create a simple init daemon. Let's look at a simpler example-I saw
some "Game Services" listed in the manual that might be pretty
simple. The definition of the games services are apparently in
[[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/services/games.scm][`/gnu/services/games.scm`]]:

#+begin_src scheme
;;; GNU Guix --- Functional package management for GNU
;;; Copyright © 2018 Arun Isaac <arunisaac@systemreboot.net>
;;;
;;; This file is part of GNU Guix.
;;;
;;; GNU Guix is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; GNU Guix is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with GNU Guix.  If not, see <http://www.gnu.org/licenses/>.

(define-module (gnu services games)
  #:use-module (gnu services)
  #:use-module (gnu services shepherd)
  #:use-module (gnu packages admin)
  #:use-module (gnu packages games)
  #:use-module (gnu system shadow)
  #:use-module (guix gexp)
  #:use-module (guix modules)
  #:use-module (guix records)
  #:use-module (ice-9 match)
  #:export (wesnothd-configuration
            wesnothd-configuration?
            wesnothd-service-type))

;;;
;;; The Battle for Wesnoth server
;;;

(define-record-type* <wesnothd-configuration>
  wesnothd-configuration make-wesnothd-configuration wesnothd-configuration?
  (package wesnothd-configuration-package
           (default wesnoth-server))
  (port wesnothd-configuration-port
        (default 15000)))

(define %wesnothd-accounts
  (list (user-account
         (name "wesnothd")
         (group "wesnothd")
         (system? #t)
         (comment "Wesnoth daemon user")
         (home-directory "/var/empty")
         (shell (file-append shadow "/sbin/nologin")))
        (user-group
         (name "wesnothd")
         (system? #t))))

(define wesnothd-shepherd-service
  (match-lambda
    (($ <wesnothd-configuration> package port)
     (with-imported-modules (source-module-closure
                             '((gnu build shepherd)))
       (shepherd-service
        (documentation "The Battle for Wesnoth server")
        (provision '(wesnoth-daemon))
        (requirement '(networking))
        (modules '((gnu build shepherd)))
        (start #~(make-forkexec-constructor/container
                  (list #$(file-append package "/bin/wesnothd")
                        "-p" #$(number->string port))
                  #:user "wesnothd" #:group "wesnothd"))
        (stop #~(make-kill-destructor)))))))

(define wesnothd-service-type
  (service-type
   (name 'wesnothd)
   (description
    "Run The Battle for Wesnoth server @command{wesnothd}.")
   (extensions
    (list (service-extension account-service-type
                             (const %wesnothd-accounts))
          (service-extension shepherd-root-service-type
                             (compose list wesnothd-shepherd-service))))
   (default-value (wesnothd-configuration))))
#+end_src

The [[https://guix.gnu.org/manual/en/html_node/Game-Services.html][Game Services reference]] says

#+begin_quote
To run wesnothd in the default configuration, instantiate it as:

`(service wesnothd-service-type)`
#+end_quote

Based on the `service` documentation, `(service some-service-type)` is
equivalent to `(service some-service-type default-arguments)`. I can't
think of sane defaults to provide to kmonad, so let's forego defaults
and provide kmonad as `(service kmonad-service-type
kmonad-arguments)`. With that in mind, let's apply
`wesnothd-service-type` to write `kmonad-service-type`:

#+begin_src scheme
  (define kmonad-service-type
    (service-type
     (name 'kmonad)
     (description
      "Run kmonad as a daemon.")
     (extensions
      (list (service-extension account-service-type
                               (const %kmonad-daemon-accounts))
            (service-extension shepherd-root-service-type
                               (compose list kmonad-shepherd-service))))))
#+end_src

First let's figure out how service-extension works. The documentation
says:

#+begin_quote
Scheme Procedure: service-extension target-type compute

Return a new extension for services of type target-type. compute must
be a one-argument procedure: fold-services calls it, passing it the
value associated with the service that provides the extension; it must
return a valid value for the target service.
#+end_quote

So in the context of `(define kmonad-service-type ...`, a `compute`
function will receive the (single) value associated with
`kmonad-service-type` (a value which we have yet to define) and will
return the value required by the extended service
`target-type`. According to the docs, [[https://guix.gnu.org/manual/en/html_node/Service-Types-and-Services.html][`account-service-type`]] gets
extended with a list of `user-group` and `user-account` objects;
[[https://guix.gnu.org/manual/en/html_node/Shepherd-Services.html][`shepherd-root-service-type`]] gets extended with a list of
`<shepherd-service>`. We should be ready to define
`%kmonad-daemon-accounts`:

#+begin_src scheme
(define %kmonad-daemon-accounts
  (list (user-account
         (name "kmonad-daemon")
         (group "kmonad-daemon")
         (system? #t)
         (comment "kmonad daemon user")
         (home-directory "/var/empty")
         (shell (file-append shadow "/sbin/nologin")))
        (user-group
         (name "kmonad-daemon")
         (system? #t))))
#+end_src

It's recommended to make a dedicated user and group for each service
(see [[https://unix.stackexchange.com/questions/29159/why-is-it-recommended-to-create-a-group-and-user-for-some-applications][stackoverflow]]) so we will do the same with kmonad. It's also a
good idea to disable login from this dedicated user by setting the
default shell to `/sbin/nologin` (see `man 8 nologin`). Now, `(const
%kmonad-daemon-accounts)` will evaluate to a function that takes some
argument--specifically whichever argument is passed to it by
`fold-services`--and return our newly-defined list of `user-account`
and `user-group` objects. We've finished extending
`account-service-type`.

Now let's extend `shepherd-root-service-type`. That means implementing
`kmonad-shepherd-service` so that it takes whatever single argument we
want it to, and outputs something that, when passed to `list`, yields
a list of `<shepherd-service>`--in other words, a single
<shepherd-service>. Before we write the function, let's decide what we
want to pass to `kmonad-shepherd-service`. Minimally, kmonad needs a
`.kbd` file to run. In theory, a user could also specify a user
account to run the daemon, or a log level, or a log output
location. But let's just start with the `.kbd` path as the single
argument:

#+begin_src scheme
  (define (kmonad-shepherd-service kbd-path)
    (shepherd-service
     (documentation "Run the kmonad daemon (kmonad-daemon)." )
     (provision '(kmonad-daemon))
     (requirement '(udev user-processes))
     (start #~(make-forkexec-constructor
               (list #$(file-append kmonad "/bin/kmonad")
                     #$kbd-path "-l info")
               #:user "kmonad-daemon" #:group "kmonad-daemon"
               #:log-file "/var/log/kmonad.log"))
     (stop #~(make-kill-destructor))))
#+end_src

We definitely need to wait for `udev`, but maybe we should also wait
for `user-processes` like the other daemons in the shepherd graph seem
to. Looking at the [[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/services/shepherd.scm][source]] for `user-processes`:

#+begin_quote
This is a synchronization point used to make sure user processes and daemons
get started only after crucial initial services have been started---file
system mounts, etc.  This is similar to the 'sysvinit' target in systemd.
#+end_quote

In theory we could explicitly wait for other shepherd services, but it
seems like this is a catch-all that applies perfectly to the
circumstance. Come to think of it, I wonder why `wesnothd` doesn't
depend on `user-processes` too. Finally, we need to specify the
`start` and `stop` fields. The [[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/build/shepherd.scm][source]] for
`make-forkexec-constructor/container` include:

#+begin_quote
This is a variant of 'make-forkexec-constructor' that starts COMMAND in
NAMESPACES, a list of Linux namespaces such as '(mnt ipc).  MAPPINGS is the
list of <file-system-mapping> to make in the case of a separate mount
namespace, in addition to essential bind-mounts such /proc.
#+end_quote

Wherease the [[https://www.gnu.org/software/shepherd/manual/html_node/Service-De_002d-and-Constructors.html#Service-De_002d-and-Constructors][docs]] for `make-forkexec-contructor` reads:

#+begin_quote
Return a procedure that forks a child process, closes all file
descriptors except the standard output and standard error descriptors,
sets the current directory to directory, sets the umask to
file-creation-mask unless it is #f, changes the environment to
environment-variables (using the environ procedure), sets the current
user to user and the current group to group unless they are #f, and
executes command (a list of strings.) The result of the procedure will
be the PID of the child process. Note that this will not work as
expected if the process “daemonizes” (forks); in that case, you will
need to pass #:pid-file, as explained below.

When pid-file is true, it must be the name of a PID file associated
with the process being launched; the return value is the PID once that
file has been created. If pid-file does not show up in less than
pid-file-timeout seconds, the service is considered as failing to
start.

When log-file is true, it names the file to which the service’s
standard output and standard error are redirected. log-file is created
if it does not exist, otherwise it is appended to.
#+end_quote

The `wesnoth` source appears not to use the `NAMESPACES` feature of
the containerized-version, so we'll stick with
`make-forexec-constructor` as is used in the [[https://guix.gnu.org/manual/en/html_node/Shepherd-Services.html][syslogd example]].

Putting it all together, and adding imports, we have:

#+begin_src scheme
  (define-module (my services kmonad)
    #:use-module (gnu services)
    #:use-module (gnu services shepherd)
    #:use-module (gnu packages haskell-apps)
    #:use-module (gnu system shadow)
    #:use-module (guix gexp)
    #:export (kmonad-service-type))

  (define %kmonad-daemon-accounts
    (list (user-account
           (name "kmonad-daemon")
           (group "kmonad-daemon")
           (system? #t)
           (comment "kmonad daemon user")
           (home-directory "/var/empty")
           (shell (file-append shadow "/sbin/nologin")))
          (user-group
           (name "kmonad-daemon")
           (system? #t))))

  (define (kmonad-shepherd-service kbd-path)
    (shepherd-service
     (documentation "Run the kmonad daemon (kmonad-daemon)." )
     (provision '(kmonad-daemon))
     (requirement '(udev user-processes))
     (start #~(make-forkexec-constructor
               (list #$(file-append kmonad "/bin/kmonad")
                     #$kbd-path "-l info")
               #:user "kmonad-daemon" #:group "kmonad-daemon"
               #:log-file "/var/log/kmonad.log"))
     (stop #~(make-kill-destructor))))

  (define kmonad-service-type
    (service-type
     (name 'kmonad)
     (description
      "Run kmonad as a daemon.")
     (extensions
      (list (service-extension account-service-type
                               (const %kmonad-daemon-accounts))
            (service-extension shepherd-root-service-type
                               (compose list kmonad-shepherd-service))))))
#+end_src

If the location where we keep local guix modules is `~/local-guix`,
then we can save the above file as
`~/local-guix/my/services/kmonad.scm`. Now we can adjust our system
config to use the new service type:

#+begin_src scheme
(use-modules (gnu))
(use-package-modules haskell-apps) ;; contains kmonad
(use-modules (my services kmonad))
;; more modules

(operating-system
  (users
    (append (list (user-account
                     (supplementary-groups
                       '("input" ;; needed by kmonad
                         ;; more groups
                         ))
                     ;; more fields
                   )
                   ;; more users
            )
            %base-user-accounts))
  (packages
    (append (list "kmonad"
             ;; more packages
            )
            %base-packages))
  (services
    (append (list (kmonad-service "/path/to/config.kbd")
                  ;; more services
            )
            (modify-services %desktop-services ;; needed to add kmonad udev rules
              (udev-service-type config =>
                (udev-configuration (inherit config)
                  (rules (cons kmonad
                    (udev-configuration-rules config))))))))
  ;; more fields
)
#+end_src

And reconfigure:

#+begin_src bash
sudo guix system -L ~/local-guix reconfigure /path/to/config.scm
#+end_src

Final thoughts
- Perhaps we could have added kmonad as a `simple-service` on top of
  mcron?
- We could submit this as a package to guix
